#! /bin/sh
# tktalk - serial and TCP/IP communication tool
# Copyright Hewlett Packard Company, 2005
# by Bruce Williams
# the next line restarts using wish \
exec wish "$0" -- "$@"

proc show_message {msg {parent .}} {
    tk_messageBox -message $msg -type ok -parent $parent
}

# Set up global defaults
array set config {}
array set defconfig {}
array set temp_config {}

set defconfig(AC_MAX) 50
set defconfig(MAXLINES) 20000
set defconfig(SCRIPTNAME) [file tail $argv0]
switch -- $tcl_platform(platform) {
    "windows" {
        set D_CONFIGFILENAME "C:\\.tktalkcfg"
        set CONFIGFILENAME "C:\\.tktalkcfg"
        set defconfig(COMMANDFILE) "C:\\.$defconfig(SCRIPTNAME)cmds"
        set defconfig(AUTOCOMPLETEFILE) "C:\\.$defconfig(SCRIPTNAME)ac"
        set defconfig(TEXTFONT) Courier
        set defconfig(DEVICE) "com1"
        set defconfig(TEXTSIZE) 8
    }
    "unix" {
        set D_CONFIGFILENAME $env(HOME)/.tktalkcfg
        set CONFIGFILENAME $env(HOME)/.tktalkcfg
        set defconfig(COMMANDFILE) $env(HOME)/.$defconfig(SCRIPTNAME)cmds
        set defconfig(AUTOCOMPLETEFILE) $env(HOME)/.$defconfig(SCRIPTNAME)ac
        switch -- $tcl_platform(os) {
            "Linux"   { set defconfig(DEVICE) "/dev/ttyS0" }
            "SunOS"   { set defconfig(DEVICE) "/dev/cua/a"}
            "HP-UX"   { set defconfig(DEVICE) "/dev/tty00"}
            "FreeBSD" { set defconfig(DEVICE) "/dev/ttyd0"}
            default   { set defconfig(DEVICE) "/dev/ttya0"}
        }
        set defconfig(TEXTFONT) lucidatypewriter
        set defconfig(TEXTSIZE) 10
    }
    default { 
        set D_CONFIGFILENAME $env(HOME)/.tktalkcfg
        set CONFIGFILENAME $env(HOME)/.tktalkcfg
        set defconfig(COMMANDFILE) $env(HOME)/.$defconfig(SCRIPTNAME)cmds
        set defconfig(AUTOCOMPLETEFILE) $env(HOME)/.$defconfig(SCRIPTNAME)ac
        set defconfig(TEXTFONT) courier
        set defconfig(DEVICE) "/dev/ttya0" 
        set defconfig(TEXTSIZE) 10
    }
}
set defconfig(BAUD) 115200
set defconfig(PARITY) n
set defconfig(DATA) 8
set defconfig(STOP) 1
set defconfig(HISTLENGTH) 100
set defconfig(BACKGROUND) "#F2F2F2"
set defconfig(FOREGROUND) "#000000"
set defconfig(FOLLOW) 0
set defconfig(AUTOCOMPLETE) 1
set defconfig(HIDDEN) 0
set defconfig(WRAP) 1
set defconfig(NUMCOMMANDS) 5
set defconfig(MAXCOMMANDS) 20
set defconfig(TAGINFO) [list]
set defconfig(LOGFILENAME) $defconfig(SCRIPTNAME).log
set defconfig(LOGDATE) 0
set defconfig(LOGDATEFORMAT) "%Y%m%d %H:%M:%S "
set defconfig(LOGAPPEND) 0

array set config [ array get defconfig ]
set fonts [lsort -dictionary [font families]]
set curoption 0
set last_open_error 0

# Create namespaces
#Preset command entry namespace
namespace eval Cmd {
    variable entryText
}

namespace eval Tag {
    variable tagList
    variable tagStopList
    variable curTagList {}
}


#History namespace for manual command entry command history
namespace eval Hist {
    variable histIndex -1
    variable histHead -1
    variable histTail -1
    variable histList
    variable histEnd [expr $config(HISTLENGTH) - 1]
    variable autoCompleteList
    variable autoCompleteMatchList
    variable curAutoCompleteMatchIndex
}

namespace eval Script {
    variable runType 0
    variable prompt "-> "
    variable curAction
    variable curActionType "Select Type"
    variable curActionParams
    variable running 0
    variable editActionCommitFunc ""
    variable actionStateList {}
    variable actionNameList {}
    variable actionList {}
    variable selectedActionIndexList {}
    variable actionTypesList    {
	                         "Send Command"
                                 "Wait For ..."
                                 "Sleep"
	                         "User Interaction"
	                         "Print Message"
                                }
    variable actionEditFuncList {
	                         "EditSendCommandAction"
                                 "EditWaitForAction"
                                 "EditSleepAction" 
	                         "EditUserInteractionAction"
	                         "EditMessageAction"
                                }
    variable actionClipboard {}
    variable actionValidate ""
    variable numberOfRepeats 1
    variable runNumber "0/0"
    variable status ""
    variable actionNames
    array set actionNames {
        ACTION_NAME_PRINT_MESSAGE     "Print Message"
        ACTION_NAME_SLEEP             "Sleep"
        ACTION_NAME_WAIT_FOR          "Wait For ..."
        ACTION_NAME_SEND_COMMAND      "Send Command"
        ACTION_NAME_USER_INTERACTION  "User Interaction"
    }
    variable actionResult pending  # timeout, done, error, ...
    variable filename ""
    variable waitingForText 0
    variable waitText ""
    variable waitTextMaxBufferSize 2000
    variable waitBuffer ""
    variable waitIdleTime
    variable waitingForIdle 0
    variable waitIdleId
}


#Log namespace for logging variables
namespace eval Log {
    variable filename "${config(SCRIPTNAME)}.log"
    variable tempfilename "${config(SCRIPTNAME)}.log"
    variable logfile
    variable logging 0
}

namespace eval Find {
    variable seltext ""
    variable tempseltext ""
    variable findup 0
    variable wholeword 0
    variable ignorecase 0
}

namespace eval SR {
    variable buf ""
    variable pending 0
    variable requested 0
    variable period 100
}

#utility to reverse a list
proc list_reverse list      {
    for    {set i [ expr [ llength $list ] - 1 ] } {$i >= 0} {incr i -1}      {
        lappend _temp [ lindex $list $i ]
     }
     return  $_temp
 }

#Attempt to autocomplete the manual command entry
proc autocomplete {win action validation value } {
   global config
   if { $config(AUTOCOMPLETE) } {
       if {$action == 1 & $value != {}} {
           set matchValue [ string map { "\*" "\\*" "\?" "\\?" "\[" "\\[" "\]" "\\]" "\\" "\\\\" } "$value" ]
           set matchList [ array get Hist::autoCompleteList "$matchValue*" ]
           if { [ llength $matchList ] } {
                set Hist::autoCompleteMatchList {}
                foreach {i j} $matchList { lappend Hist::autoCompleteMatchList [list $i $j] }
                set Hist::autoCompleteMatchList [lsort -index 1 -integer -decreasing $Hist::autoCompleteMatchList]
                set Hist::curAutoCompleteMatchIndex 0
                $win delete 0 end;  
                $win insert end [lindex [lindex $Hist::autoCompleteMatchList 0] 0]
                $win selection range [string length $value] end
                $win icursor [string length $value]
           } else {
                $win selection clear
                set Hist::autoCompleteMatchIndex -1
           }
       } else {
           $win selection clear
       }
       after idle [list $win configure -validate $validation]
   }
   return 1
}

proc trim_autocomplete {} {
    set empty_list [list]
    set search_id [array startsearch Hist::autoCompleteList]
    while { [array anymore Hist::autoCompleteList $search_id] } {
        set name [array nextelement Hist::autoCompleteList $search_id]
        set newval [expr $Hist::autoCompleteList($name) / 2]
        if { $newval } {
            set Hist::autoCompleteList($name) $newval
        } else {
            lappend empty_list "$name"
        }
    }
    array donesearch Hist::autoCompleteList $search_id

    foreach name $empty_list {
        unset Hist::autoCompleteList($name)
    }
}

# Go to next matched auto completion if there are any
proc next_autocomplete {} {
    if { $Hist::curAutoCompleteMatchIndex != -1 && \
         $Hist::curAutoCompleteMatchIndex < [expr [llength $Hist::autoCompleteMatchList] - 1] } {
        incr Hist::curAutoCompleteMatchIndex
        set curIndex [.cmdent index insert]
        set pop [lindex [lindex $Hist::autoCompleteMatchList $Hist::curAutoCompleteMatchIndex] 0]
        .cmdent configure -validate none
        .cmdent delete 0 end;  .cmdent insert end $pop
        .cmdent selection range $curIndex end
        .cmdent icursor $curIndex
        .cmdent configure -validate none
        after idle [.cmdent configure -validate all -validatecommand {autocomplete %W %d %v %P}]
    }
}

# Go to previous matched auto completion if there are any
proc prev_autocomplete {} {
    if { $Hist::curAutoCompleteMatchIndex > 0 } {
        set Hist::curAutoCompleteMatchIndex [expr $Hist::curAutoCompleteMatchIndex - 1 ]
        set curIndex [.cmdent index insert]
        set pop [lindex [lindex $Hist::autoCompleteMatchList $Hist::curAutoCompleteMatchIndex] 0]
        .cmdent configure -validate none
        .cmdent delete 0 end;  .cmdent insert end $pop
        .cmdent selection range $curIndex end
        .cmdent icursor $curIndex
        after idle [.cmdent configure -validate all -validatecommand {autocomplete %W %d %v %P}]
    }
}

#Display a modal window containing some text
proc show_text {win txt cmd} {
   global config
    if {"$win" == "."} { set parent "" } else { set parent $win }
    text $parent.txt -yscrollcommand "$parent.srl_y set"  \
    -width 80 -height 40 -font "${config(TEXTFONT)} ${config(TEXTSIZE)}"
    scrollbar $parent.srl_y -orient v -command "$parent.txt yview"
    button $parent.okbut -text OK -command "$cmd"
    grid $parent.txt -in $win -row 0 -column 0 -sticky nsew
    grid $parent.srl_y -in $win -row 0 -column 1 -sticky ns
    grid $parent.okbut -in $win -row 1 -column 0
    grid $parent.okbut -in $win -columnspan 2
    grid rowconfigure $win 0 -weight 1
    grid columnconfigure $win 0 -weight 1
    $parent.txt insert end "$txt"
    $parent.txt configure -state disabled
}

#List colors
proc list_colors {win cmd} {
   global config
    show_text $win \
    "${config(SCRIPTNAME)} colors

${config(SCRIPTNAME)} colors are specified just like Xterm colors.
You can specify a color as either a color name, or as an RGB
triplet in the format \#RRGGBB, where RR, GG, and BB are the
red, green, and blue component levels as 2-digit hex values 
between 00h and FFh.  For example, '\#FFFF00' would result
in a bright yellow.  When specifying colors this way, be
sure to use single quotes around the color so that your
shell does not interpret the \# character as the beginning
of a comment.

If specifying a color by name, here are the color names and
their associated RGB values (if RGB are 0, 0, and 0, then
the RGB components may not be known; just experiment to see
if it's a color you like):
            Color Name                 R     G     B
            -------------------------  ---   ---   ---
            alice blue                 240   248   248
            AliceBlue                  240   248   248
            antique white              250   235   235
            AntiqueWhite               250   235   235
            AntiqueWhite1              255   239   239
            AntiqueWhite2              238   223   223
            AntiqueWhite3              205   192   192
            AntiqueWhite4              139   131   131
            aquamarine                 127   255   255
            aquamarine1                127   255   255
            aquamarine2                118   238   238
            aquamarine3                102   205   205
            aquamarine4                 69   139   139
            azure                      240   255   255
            azure1                     240   255   255
            azure2                     224   238   238
            azure3                     193   205   205
            azure4                     131   139   139
            beige                      245   245   245
            bisque                     255   228   228
            bisque1                    255   228   228
            bisque2                    238   213   213
            bisque3                    205   183   183
            bisque4                    139   125   125
            black                        0     0     0
            blanched almond            255   235   235
            BlanchedAlmond             255   235   235
            blue                         0     0     0
            blue violet                138    43    43
            blue1                        0     0     0
            blue2                        0     0     0
            blue3                        0     0     0
            blue4                        0     0     0
            BlueViolet                 138    43    43
            brown                      165    42    42
            brown1                     255    64    64
            brown2                     238    59    59
            brown3                     205    51    51
            brown4                     139    35    35
            burlywood                  222   184   184
            burlywood1                 255   211   211
            burlywood2                 238   197   197
            burlywood3                 205   170   170
            burlywood4                 139   115   115
            cadet blue                  95   158   158
            CadetBlue                   95   158   158
            CadetBlue1                 152   245   245
            CadetBlue2                 142   229   229
            CadetBlue3                 122   197   197
            CadetBlue4                  83   134   134
            chartreuse                 127   255   255
            chartreuse1                127   255   255
            chartreuse2                118   238   238
            chartreuse3                102   205   205
            chartreuse4                 69   139   139
            chocolate                  210   105   105
            chocolate1                 255   127   127
            chocolate2                 238   118   118
            chocolate3                 205   102   102
            chocolate4                 139    69    69
            coral                      255   127   127
            coral1                     255   114   114
            coral2                     238   106   106
            coral3                     205    91    91
            coral4                     139    62    62
            cornflower blue            100   149   149
            CornflowerBlue             100   149   149
            cornsilk                   255   248   248
            cornsilk1                  255   248   248
            cornsilk2                  238   232   232
            cornsilk3                  205   200   200
            cornsilk4                  139   136   136
            cyan                         0   255   255
            cyan1                        0   255   255
            cyan2                        0   238   238
            cyan3                        0   205   205
            cyan4                        0   139   139
            dark blue                    0     0     0
            dark cyan                    0   139   139
            dark goldenrod             184   134   134
            dark gray                  169   169   169
            dark green                   0   100   100
            dark grey                  169   169   169
            dark khaki                 189   183   183
            dark magenta               139     0     0
            dark olive green            85   107   107
            dark orange                255   140   140
            dark orchid                153    50    50
            dark red                   139     0     0
            dark salmon                233   150   150
            dark sea green             143   188   188
            dark slate blue             72    61    61
            dark slate gray             47    79    79
            dark slate grey             47    79    79
            dark turquoise               0   206   206
            dark violet                148     0     0
            DarkBlue                     0     0     0
            DarkCyan                     0   139   139
            DarkGoldenrod              184   134   134
            DarkGoldenrod1             255   185   185
            DarkGoldenrod2             238   173   173
            DarkGoldenrod3             205   149   149
            DarkGoldenrod4             139   101   101
            DarkGray                   169   169   169
            DarkGreen                    0   100   100
            DarkGrey                   169   169   169
            DarkKhaki                  189   183   183
            DarkMagenta                139     0     0
            DarkOliveGreen              85   107   107
            DarkOliveGreen1            202   255   255
            DarkOliveGreen2            188   238   238
            DarkOliveGreen3            162   205   205
            DarkOliveGreen4            110   139   139
            DarkOrange                 255   140   140
            DarkOrange1                255   127   127
            DarkOrange2                238   118   118
            DarkOrange3                205   102   102
            DarkOrange4                139    69    69
            DarkOrchid                 153    50    50
            DarkOrchid1                191    62    62
            DarkOrchid2                178    58    58
            DarkOrchid3                154    50    50
            DarkOrchid4                104    34    34
            DarkRed                    139     0     0
            DarkSalmon                 233   150   150
            DarkSeaGreen               143   188   188
            DarkSeaGreen1              193   255   255
            DarkSeaGreen2              180   238   238
            DarkSeaGreen3              155   205   205
            DarkSeaGreen4              105   139   139
            DarkSlateBlue               72    61    61
            DarkSlateGray               47    79    79
            DarkSlateGray1             151   255   255
            DarkSlateGray2             141   238   238
            DarkSlateGray3             121   205   205
            DarkSlateGray4              82   139   139
            DarkSlateGrey               47    79    79
            DarkTurquoise                0   206   206
            DarkViolet                 148     0     0
            deep pink                  255    20    20
            deep sky blue                0   191   191
            DeepPink                   255    20    20
            DeepPink1                  255    20    20
            DeepPink2                  238    18    18
            DeepPink3                  205    16    16
            DeepPink4                  139    10    10
            DeepSkyBlue                  0   191   191
            DeepSkyBlue1                 0   191   191
            DeepSkyBlue2                 0   178   178
            DeepSkyBlue3                 0   154   154
            DeepSkyBlue4                 0   104   104
            dim gray                   105   105   105
            dim grey                   105   105   105
            DimGray                    105   105   105
            DimGrey                    105   105   105
            dodger blue                 30   144   144
            DodgerBlue                  30   144   144
            DodgerBlue1                 30   144   144
            DodgerBlue2                 28   134   134
            DodgerBlue3                 24   116   116
            DodgerBlue4                 16    78    78
            firebrick                  178    34    34
            firebrick1                 255    48    48
            firebrick2                 238    44    44
            firebrick3                 205    38    38
            firebrick4                 139    26    26
            floral white               255   250   250
            FloralWhite                255   250   250
            forest green                34   139   139
            ForestGreen                 34   139   139
            gainsboro                  220   220   220
            ghost white                248   248   248
            GhostWhite                 248   248   248
            gold                       255   215   215
            gold1                      255   215   215
            gold2                      238   201   201
            gold3                      205   173   173
            gold4                      139   117   117
            goldenrod                  218   165   165
            goldenrod1                 255   193   193
            goldenrod2                 238   180   180
            goldenrod3                 205   155   155
            goldenrod4                 139   105   105
            gray                       190   190   190
            gray0                        0     0     0
            gray1                        3     3     3
            gray2                        5     5     5
            gray3                        8     8     8
            gray4                       10    10    10
            gray5                       13    13    13
            gray6                       15    15    15
            gray7                       18    18    18
            gray8                       20    20    20
            gray9                       23    23    23
            gray10                      26    26    26
            gray11                      28    28    28
            gray12                      31    31    31
            gray13                      33    33    33
            gray14                      36    36    36
            gray15                      38    38    38
            gray16                      41    41    41
            gray17                      43    43    43
            gray18                      46    46    46
            gray19                      48    48    48
            gray20                      51    51    51
            gray21                      54    54    54
            gray22                      56    56    56
            gray23                      59    59    59
            gray24                      61    61    61
            gray25                      64    64    64
            gray26                      66    66    66
            gray27                      69    69    69
            gray28                      71    71    71
            gray29                      74    74    74
            gray30                      77    77    77
            gray31                      79    79    79
            gray32                      82    82    82
            gray33                      84    84    84
            gray34                      87    87    87
            gray35                      89    89    89
            gray36                      92    92    92
            gray37                      94    94    94
            gray38                      97    97    97
            gray39                      99    99    99
            gray40                     102   102   102
            gray41                     105   105   105
            gray42                     107   107   107
            gray43                     110   110   110
            gray44                     112   112   112
            gray45                     115   115   115
            gray46                     117   117   117
            gray47                     120   120   120
            gray48                     122   122   122
            gray49                     125   125   125
            gray50                     127   127   127
            gray51                     130   130   130
            gray52                     133   133   133
            gray53                     135   135   135
            gray54                     138   138   138
            gray55                     140   140   140
            gray56                     143   143   143
            gray57                     145   145   145
            gray58                     148   148   148
            gray59                     150   150   150
            gray60                     153   153   153
            gray61                     156   156   156
            gray62                     158   158   158
            gray63                     161   161   161
            gray64                     163   163   163
            gray65                     166   166   166
            gray66                     168   168   168
            gray67                     171   171   171
            gray68                     173   173   173
            gray69                     176   176   176
            gray70                     179   179   179
            gray71                     181   181   181
            gray72                     184   184   184
            gray73                     186   186   186
            gray74                     189   189   189
            gray75                     191   191   191
            gray76                     194   194   194
            gray77                     196   196   196
            gray78                     199   199   199
            gray79                     201   201   201
            gray80                     204   204   204
            gray81                     207   207   207
            gray82                     209   209   209
            gray83                     212   212   212
            gray84                     214   214   214
            gray85                     217   217   217
            gray86                     219   219   219
            gray87                     222   222   222
            gray88                     224   224   224
            gray89                     227   227   227
            gray90                     229   229   229
            gray91                     232   232   232
            gray92                     235   235   235
            gray93                     237   237   237
            gray94                     240   240   240
            gray95                     242   242   242
            gray96                     245   245   245
            gray97                     247   247   247
            gray98                     250   250   250
            gray99                     252   252   252
            gray100                    255   255   255
            green                        0   255   255
            green yellow               173   255   255
            green1                       0   255   255
            green2                       0   238   238
            green3                       0   205   205
            green4                       0   139   139
            GreenYellow                173   255   255
            grey                       190   190   190
            grey0                        0     0     0
            grey1                        3     3     3
            grey2                        5     5     5
            grey3                        8     8     8
            grey4                       10    10    10
            grey5                       13    13    13
            grey6                       15    15    15
            grey7                       18    18    18
            grey8                       20    20    20
            grey9                       23    23    23
            grey10                      26    26    26
            grey11                      28    28    28
            grey12                      31    31    31
            grey13                      33    33    33
            grey14                      36    36    36
            grey15                      38    38    38
            grey16                      41    41    41
            grey17                      43    43    43
            grey18                      46    46    46
            grey19                      48    48    48
            grey20                      51    51    51
            grey21                      54    54    54
            grey22                      56    56    56
            grey23                      59    59    59
            grey24                      61    61    61
            grey25                      64    64    64
            grey26                      66    66    66
            grey27                      69    69    69
            grey28                      71    71    71
            grey29                      74    74    74
            grey30                      77    77    77
            grey31                      79    79    79
            grey32                      82    82    82
            grey33                      84    84    84
            grey34                      87    87    87
            grey35                      89    89    89
            grey36                      92    92    92
            grey37                      94    94    94
            grey38                      97    97    97
            grey39                      99    99    99
            grey40                     102   102   102
            grey41                     105   105   105
            grey42                     107   107   107
            grey43                     110   110   110
            grey44                     112   112   112
            grey45                     115   115   115
            grey46                     117   117   117
            grey47                     120   120   120
            grey48                     122   122   122
            grey49                     125   125   125
            grey50                     127   127   127
            grey51                     130   130   130
            grey52                     133   133   133
            grey53                     135   135   135
            grey54                     138   138   138
            grey55                     140   140   140
            grey56                     143   143   143
            grey57                     145   145   145
            grey58                     148   148   148
            grey59                     150   150   150
            grey60                     153   153   153
            grey61                     156   156   156
            grey62                     158   158   158
            grey63                     161   161   161
            grey64                     163   163   163
            grey65                     166   166   166
            grey66                     168   168   168
            grey67                     171   171   171
            grey68                     173   173   173
            grey69                     176   176   176
            grey70                     179   179   179
            grey71                     181   181   181
            grey72                     184   184   184
            grey73                     186   186   186
            grey74                     189   189   189
            grey75                     191   191   191
            grey76                     194   194   194
            grey77                     196   196   196
            grey78                     199   199   199
            grey79                     201   201   201
            grey80                     204   204   204
            grey81                     207   207   207
            grey82                     209   209   209
            grey83                     212   212   212
            grey84                     214   214   214
            grey85                     217   217   217
            grey86                     219   219   219
            grey87                     222   222   222
            grey88                     224   224   224
            grey89                     227   227   227
            grey90                     229   229   229
            grey91                     232   232   232
            grey92                     235   235   235
            grey93                     237   237   237
            grey94                     240   240   240
            grey95                     242   242   242
            grey96                     245   245   245
            grey97                     247   247   247
            grey98                     250   250   250
            grey99                     252   252   252
            grey100                    255   255   255
            honeydew                   240   255   255
            honeydew1                  240   255   255
            honeydew2                  224   238   238
            honeydew3                  193   205   205
            honeydew4                  131   139   139
            hot pink                   255   105   105
            HotPink                    255   105   105
            HotPink1                   255   110   110
            HotPink2                   238   106   106
            HotPink3                   205    96    96
            HotPink4                   139    58    58
            indian red                 205    92    92
            IndianRed                  205    92    92
            IndianRed1                 255   106   106
            IndianRed2                 238    99    99
            IndianRed3                 205    85    85
            IndianRed4                 139    58    58
            ivory                      255   255   255
            ivory1                     255   255   255
            ivory2                     238   238   238
            ivory3                     205   205   205
            ivory4                     139   139   139
            khaki                      240   230   230
            khaki1                     255   246   246
            khaki2                     238   230   230
            khaki3                     205   198   198
            khaki4                     139   134   134
            lavender                   230   230   230
            lavender blush             255   240   240
            LavenderBlush              255   240   240
            LavenderBlush1             255   240   240
            LavenderBlush2             238   224   224
            LavenderBlush3             205   193   193
            LavenderBlush4             139   131   131
            lawn green                 124   252   252
            LawnGreen                  124   252   252
            lemon chiffon              255   250   250
            LemonChiffon               255   250   250
            LemonChiffon1              255   250   250
            LemonChiffon2              238   233   233
            LemonChiffon3              205   201   201
            LemonChiffon4              139   137   137
            light blue                 173   216   216
            light coral                240   128   128
            light cyan                 224   255   255
            light goldenrod            238   221   221
            light goldenrod yellow     250   250   250
            light gray                 211   211   211
            light green                144   238   238
            light grey                 211   211   211
            light pink                 255   182   182
            light salmon               255   160   160
            light sea green             32   178   178
            light sky blue             135   206   206
            light slate blue           132   112   112
            light slate gray           119   136   136
            light slate grey           119   136   136
            light steel blue           176   196   196
            light yellow               255   255   255
            LightBlue                  173   216   216
            LightBlue1                 191   239   239
            LightBlue2                 178   223   223
            LightBlue3                 154   192   192
            LightBlue4                 104   131   131
            LightCoral                 240   128   128
            LightCyan                  224   255   255
            LightCyan1                 224   255   255
            LightCyan2                 209   238   238
            LightCyan3                 180   205   205
            LightCyan4                 122   139   139
            LightGoldenrod             238   221   221
            LightGoldenrod1            255   236   236
            LightGoldenrod2            238   220   220
            LightGoldenrod3            205   190   190
            LightGoldenrod4            139   129   129
            LightGoldenrodYellow       250   250   250
            LightGray                  211   211   211
            LightGreen                 144   238   238
            LightGrey                  211   211   211
            LightPink                  255   182   182
            LightPink1                 255   174   174
            LightPink2                 238   162   162
            LightPink3                 205   140   140
            LightPink4                 139    95    95
            LightSalmon                255   160   160
            LightSalmon1               255   160   160
            LightSalmon2               238   149   149
            LightSalmon3               205   129   129
            LightSalmon4               139    87    87
            LightSeaGreen               32   178   178
            LightSkyBlue               135   206   206
            LightSkyBlue1              176   226   226
            LightSkyBlue2              164   211   211
            LightSkyBlue3              141   182   182
            LightSkyBlue4               96   123   123
            LightSlateBlue             132   112   112
            LightSlateGray             119   136   136
            LightSlateGrey             119   136   136
            LightSteelBlue             176   196   196
            LightSteelBlue1            202   225   225
            LightSteelBlue2            188   210   210
            LightSteelBlue3            162   181   181
            LightSteelBlue4            110   123   123
            LightYellow                255   255   255
            LightYellow1               255   255   255
            LightYellow2               238   238   238
            LightYellow3               205   205   205
            LightYellow4               139   139   139
            lime green                  50   205   205
            LimeGreen                   50   205   205
            linen                      250   240   240
            magenta                    255     0     0
            magenta1                   255     0     0
            magenta2                   238     0     0
            magenta3                   205     0     0
            magenta4                   139     0     0
            maroon                     176    48    48
            maroon1                    255    52    52
            maroon2                    238    48    48
            maroon3                    205    41    41
            maroon4                    139    28    28
            medium aquamarine          102   205   205
            medium blue                  0     0     0
            medium orchid              186    85    85
            medium purple              147   112   112
            medium sea green            60   179   179
            medium slate blue          123   104   104
            medium spring green          0   250   250
            medium turquoise            72   209   209
            medium violet red          199    21    21
            MediumAquamarine           102   205   205
            MediumBlue                   0     0     0
            MediumOrchid               186    85    85
            MediumOrchid1              224   102   102
            MediumOrchid2              209    95    95
            MediumOrchid3              180    82    82
            MediumOrchid4              122    55    55
            MediumPurple               147   112   112
            MediumPurple1              171   130   130
            MediumPurple2              159   121   121
            MediumPurple3              137   104   104
            MediumPurple4               93    71    71
            MediumSeaGreen              60   179   179
            MediumSlateBlue            123   104   104
            MediumSpringGreen            0   250   250
            MediumTurquoise             72   209   209
            MediumVioletRed            199    21    21
            midnight blue               25    25    25
            MidnightBlue                25    25    25
            mint cream                 245   255   255
            MintCream                  245   255   255
            misty rose                 255   228   228
            MistyRose                  255   228   228
            MistyRose1                 255   228   228
            MistyRose2                 238   213   213
            MistyRose3                 205   183   183
            MistyRose4                 139   125   125
            moccasin                   255   228   228
            navajo white               255   222   222
            NavajoWhite                255   222   222
            NavajoWhite1               255   222   222
            NavajoWhite2               238   207   207
            NavajoWhite3               205   179   179
            NavajoWhite4               139   121   121
            navy                         0     0     0
            navy blue                    0     0     0
            NavyBlue                     0     0     0
            old lace                   253   245   245
            OldLace                    253   245   245
            olive drab                 107   142   142
            OliveDrab                  107   142   142
            OliveDrab1                 192   255   255
            OliveDrab2                 179   238   238
            OliveDrab3                 154   205   205
            OliveDrab4                 105   139   139
            orange                     255   165   165
            orange red                 255    69    69
            orange1                    255   165   165
            orange2                    238   154   154
            orange3                    205   133   133
            orange4                    139    90    90
            OrangeRed                  255    69    69
            OrangeRed1                 255    69    69
            OrangeRed2                 238    64    64
            OrangeRed3                 205    55    55
            OrangeRed4                 139    37    37
            orchid                     218   112   112
            orchid1                    255   131   131
            orchid2                    238   122   122
            orchid3                    205   105   105
            orchid4                    139    71    71
            pale goldenrod             238   232   232
            pale green                 152   251   251
            pale turquoise             175   238   238
            pale violet red            219   112   112
            PaleGoldenrod              238   232   232
            PaleGreen                  152   251   251
            PaleGreen1                 154   255   255
            PaleGreen2                 144   238   238
            PaleGreen3                 124   205   205
            PaleGreen4                  84   139   139
            PaleTurquoise              175   238   238
            PaleTurquoise1             187   255   255
            PaleTurquoise2             174   238   238
            PaleTurquoise3             150   205   205
            PaleTurquoise4             102   139   139
            PaleVioletRed              219   112   112
            PaleVioletRed1             255   130   130
            PaleVioletRed2             238   121   121
            PaleVioletRed3             205   104   104
            PaleVioletRed4             139    71    71
            papaya whip                255   239   239
            PapayaWhip                 255   239   239
            peach puff                 255   218   218
            PeachPuff                  255   218   218
            PeachPuff1                 255   218   218
            PeachPuff2                 238   203   203
            PeachPuff3                 205   175   175
            PeachPuff4                 139   119   119
            peru                       205   133   133
            pink                       255   192   192
            pink1                      255   181   181
            pink2                      238   169   169
            pink3                      205   145   145
            pink4                      139    99    99
            plum                       221   160   160
            plum1                      255   187   187
            plum2                      238   174   174
            plum3                      205   150   150
            plum4                      139   102   102
            powder blue                176   224   224
            PowderBlue                 176   224   224
            purple                     160    32    32
            purple1                    155    48    48
            purple2                    145    44    44
            purple3                    125    38    38
            purple4                     85    26    26
            red                        255     0     0
            red1                       255     0     0
            red2                       238     0     0
            red3                       205     0     0
            red4                       139     0     0
            rosy brown                 188   143   143
            RosyBrown                  188   143   143
            RosyBrown1                 255   193   193
            RosyBrown2                 238   180   180
            RosyBrown3                 205   155   155
            RosyBrown4                 139   105   105
            royal blue                  65   105   105
            RoyalBlue                   65   105   105
            RoyalBlue1                  72   118   118
            RoyalBlue2                  67   110   110
            RoyalBlue3                  58    95    95
            RoyalBlue4                  39    64    64
            saddle brown               139    69    69
            SaddleBrown                139    69    69
            salmon                     250   128   128
            salmon1                    255   140   140
            salmon2                    238   130   130
            salmon3                    205   112   112
            salmon4                    139    76    76
            sandy brown                244   164   164
            SandyBrown                 244   164   164
            sea green                   46   139   139
            SeaGreen                    46   139   139
            SeaGreen1                   84   255   255
            SeaGreen2                   78   238   238
            SeaGreen3                   67   205   205
            SeaGreen4                   46   139   139
            seashell                   255   245   245
            seashell1                  255   245   245
            seashell2                  238   229   229
            seashell3                  205   197   197
            seashell4                  139   134   134
            sienna                     160    82    82
            sienna1                    255   130   130
            sienna2                    238   121   121
            sienna3                    205   104   104
            sienna4                    139    71    71
            sky blue                   135   206   206
            SkyBlue                    135   206   206
            SkyBlue1                   135   206   206
            SkyBlue2                   126   192   192
            SkyBlue3                   108   166   166
            SkyBlue4                    74   112   112
            slate blue                 106    90    90
            slate gray                 112   128   128
            slate grey                 112   128   128
            SlateBlue                  106    90    90
            SlateBlue1                 131   111   111
            SlateBlue2                 122   103   103
            SlateBlue3                 105    89    89
            SlateBlue4                  71    60    60
            SlateGray                  112   128   128
            SlateGray1                 198   226   226
            SlateGray2                 185   211   211
            SlateGray3                 159   182   182
            SlateGray4                 108   123   123
            SlateGrey                  112   128   128
            snow                       255   250   250
            snow1                      255   250   250
            snow2                      238   233   233
            snow3                      205   201   201
            snow4                      139   137   137
            spring green                 0   255   255
            SpringGreen                  0   255   255
            SpringGreen1                 0   255   255
            SpringGreen2                 0   238   238
            SpringGreen3                 0   205   205
            SpringGreen4                 0   139   139
            steel blue                  70   130   130
            SteelBlue                   70   130   130
            SteelBlue1                  99   184   184
            SteelBlue2                  92   172   172
            SteelBlue3                  79   148   148
            SteelBlue4                  54   100   100
            tan                        210   180   180
            tan1                       255   165   165
            tan2                       238   154   154
            tan3                       205   133   133
            tan4                       139    90    90
            thistle                    216   191   191
            thistle1                   255   225   225
            thistle2                   238   210   210
            thistle3                   205   181   181
            thistle4                   139   123   123
            tomato                     255    99    99
            tomato1                    255    99    99
            tomato2                    238    92    92
            tomato3                    205    79    79
            tomato4                    139    54    54
            turquoise                   64   224   224
            turquoise1                   0   245   245
            turquoise2                   0   229   229
            turquoise3                   0   197   197
            turquoise4                   0   134   134
            violet                     238   130   130
            violet red                 208    32    32
            VioletRed                  208    32    32
            VioletRed1                 255    62    62
            VioletRed2                 238    58    58
            VioletRed3                 205    50    50
            VioletRed4                 139    34    34
            wheat                      245   222   222
            wheat1                     255   231   231
            wheat2                     238   216   216
            wheat3                     205   186   186
            wheat4                     139   126   126
            white                      255   255   255
            white smoke                245   245   245
            WhiteSmoke                 245   245   245
            yellow                     255   255   255
            yellow green               154   205   205
            yellow1                    255   255   255
            yellow2                    238   238   238
            yellow3                    205   205   205
            yellow4                    139   139   139
            YellowGreen                154   205   205" "$cmd"
}

#Usage statement
proc usage {win error cmd} {
   global config defconfig
    show_text $win "$error
Usage: ${defconfig(SCRIPTNAME)} \[options\]
    ${defconfig(SCRIPTNAME)} is a serial and TCP/IP communication tool.  It allows a user 
    to define preset commands that can be sent to a serial device or TCP/IP
    socket with a single button click.  It also allows commands to be 
    manually entered, and it keeps track of manual command history, which 
    can be recalled using the up and down arrow keys.  The user defined 
    preset commands can be saved to a command file.

    Options:
        -c config_file
            Use a config file other than the default (or the default settings
            below).  Configurations can be saved to configuration files by 
            choosing File->Save Configuration As in the menu.  By
            default, the default configuration file is read (if present).  You
            can save the current settings to the default configuration file
            by choosing File->Save Configuration in the menu, or
            by pressing Ctrl-O.  The configuration does not contain
            the preset command entry information (except the number of
            entries to be displayed), since this is stored in a 
            separate file.  Config file values can be overridden using
            the other options below.
        -d connection_path
            The connection_path can either be the full device file name
            for a serial port (e.g. com1, com2, ... on Windows or 
            /dev/ttyS0, /dev/ttyS1, ...  on Linux), or if connecting through
            a TCP socket, the host name or IP address and port number
            separated by a colon (e.g. 111.111.111.111:1234, localhost:80).
            The port and its preceding colon may be omitted, in which case
            the default port is 7435.
            (default is ${defconfig(DEVICE)}).
        -n N
            Provide N (N between 0 and 20) command lines at top for preset
            commands. (default is ${defconfig(NUMCOMMANDS)})
        -h 
            Hide preset command entries on startup.  Pressing Ctrl-H will
            toggle hiding/unhiding the preset command entries. (default
            is unhidden preset command entries)
        -f commandfile
            Read/write the preset commands to/from commandfile.  NOTE: the
            preset commands are not automatically written to the command
            file; to save your preset commands, you must select 
            File->Save Commands or type Ctrl-S after entering in your 
            preset commands.  (default is ${defconfig(COMMANDFILE)})
        -nowrap
            Disable output line wrapping.  This will cause a horizontal
            scrollbar to be added at the bottom of the output buffer so
            that you can scroll to output that would normally have been
            wrapped.
        -baud N
            Set the baud rate. Ignored if the connection path is a TCP
            socket host IP/port.  (default is ${defconfig(BAUD)})
        -parity X
            Set the parity.  X is one of the following letters: n, o, e, m, s;
            respectively signifying the parity options of ``none'', ``odd'', 
            ``even'', ``mark'', or ``space''.  Ignored if the connection path 
            is a TCP socket host IP/port.  (default is ${defconfig(PARITY)})
        -datasize N
            Set the number of data bits.  N is the number of data bits 
            and should be an integer from 5 to 8.  Ignored if the 
            connection path is a TCP socket host IP/port.
            (default is ${defconfig(DATA)})
        -stopbits N
            Set the number of stop bits.  N is 1 or 2.  Ignored if 
            the connection path is a TCP socket host IP/port.
            (default is ${defconfig(STOP)})
        -fontsize N
            Set the buffer and entry font size. (default is ${defconfig(TEXTSIZE)})
        -fontfamily family
            Set the buffer and entry font family to family  Examples 
            are helvetica, lucidatypewriter, courier, lucida, utopia,
            and times. (default is ${defconfig(TEXTFONT)})
        -fg foregroundcolor
            Set the buffer and command window foreground color to 
            foregroundcolor. See \"Colors\" to see how to specify colors. 
            (default is ${defconfig(FOREGROUND)})
        -bg backgroundcolor
            Set the buffer and command window background color to
            backgroundcolor.  See \"Colors\" to see how to specify colors. 
            (default is ${defconfig(BACKGROUND)})
        -tag tagstart:tagend:fgcolor\[:bgcolor\]
            Set on-the-fly character tagging so that characters printed between 
            the tagstart and tagend characters have foreground color fgcolor
            and background color bgcolor.  tagstart and tagend are the decimal
            values for the unicode characters.  The tagstart and tag end
            characters themselves are not printed.  The special fgcolor
            value of \"reverse\" will swap the normal background and
            foreground colors, regardless of the bgcolor value.  If either
            of the fgcolor or bgcolor are empty, then the current foreground
            or background color will be preserved, respectively.  You may
            enter multiple tags.  When tags overlap and bgcolor or fgcolor
            for the different tags conflict, the colors of the last tag 
            activated takes priority.  tagstart and tagend cannot have
            the same values.  You may leave the last colon and bgcolor
            off entirely if you only want to change the foreground color or
            you are specifying \"reverse\" in place of fgcolor.  Be sure to
            enclose the tag in quotation marks if either of the colors have
            spaces in their names.
            Example tags:
                Red text on current background:            254:250:red
                    To activate: printf(\"%cMy red text%c\", 254, 250);
                Red text on blue background:               94:36:red:blue
                    To activate: printf(\"^My red on blue bg text\$\");
                Current colored text on blue background:   254:250::blue
                    To activate: printf(\"%cMy blue bg text%c\", 254, 250);
                Reverse the bg and fg:                     36:94:reverse
                    To activate: printf(\"\$My reversed text^\");
        -colors
            List the colors that can be specified for the -fg and -bg options
        -scroll
            Reset scrollback on display activity. (default is no scrollback
            reset on display activity)
        -ac autocomplete
            Turn on/off manual command autocompletion.  Autocompletion is
            done using the matching previous command that has been used the
            most frequently.  If matches are found, the list of matches can
            be searched forward and backward using Tab and Shift-Tab,
            respectively.  autocomplete is either 'on' or 'off'. (default
            is on)
        -acfile filename
            Set the autocomplete history file.  This file stores the manual
            command autocomplete list so that you don\'t lose your
            autocompletion match list if you exit the program.  This
            can also be useful if you are running ${defconfig(SCRIPTNAME)} for two or more
            totally different applications, and wish to have different
            autocomplete history files for each application.  filename is the 
            name of the file.  If you don\'t want to save the autocomplete 
            list when the program is shut down, use \"none\" for the file 
            name.  (default is ${defconfig(AUTOCOMPLETEFILE)})

    Searching for and/or Tagging Text
        You can search for and tag/highlight text in the text buffer in two 
        different ways.  If you just want to tag all occurances of some text,
        just select one instance of the text you want to search for and hit 
        Ctrl-T.  You can clear the tagging by hitting Ctrl-K.  If you want to 
        search for text, use Ctrl-F or the Find menu.  From the Find dialog 
        you can choose the search direction, whether or not to search for a 
        whole word, and whether or not to ignore case in the search.  Tagging 
        may also be done from the Find dialogue.

    Preset Command Entries
        Preset command entries are used for frequently sent commands.  You
        can put comments at the ends of the commands by preceding the comment
        with '#/'.  All space immediately before '#/' and all text after will
        be ignored when the command is sent.

    Colors
        To specify a color, use the color name.  Color names and their RGB
        values are listed by specifying the -colors option.\n" "$cmd"
}

#Procedure to send a command from command entry number
proc sendcmd num {
    # num is the index of the command entry
    if { [regexp {^(.*\S+) *#\/.*$|^\s*#\/.*$} $Cmd::entryText($num) wholematch cmdmatch] } {
        send "$cmdmatch"
    } else {
        send "$Cmd::entryText($num)"
    }
    focus .cmdent
}

#Procedure to send the command cmd
proc send cmd {
    global SRLFILE
    .txtfrm.txt see end
    #Wait for idle between each character sent to the connection in
    #order to prevent lost bytes.  This should not be necessary, but it
    #appears to help.
    for { set ind 0 } { $ind < [string length "$cmd"] } { incr ind } {
        puts -nonewline $SRLFILE [string index "$cmd" $ind]
        set x 0
        after 5 set x 1
        vwait x
    }
    puts -nonewline $SRLFILE \n
    focus .cmdent
}

#Procedure to dump the current buffer to a user selected file
proc dump {} {
    set filename [tk_getSaveFile -title "Choose dump file"]
    if { $filename != "" } {
        if [catch {open $filename w} fileId] {
            tk_messageBox -icon error -type ok \
                -message "Could not dump to file $filename: $fileId"
        } else {
            puts -nonewline $fileId [.txtfrm.txt get 1.0 end]
            close $fileId
        }
    }
}

#Procedure to clear the current buffer
proc cleartxt {} {
    .txtfrm.txt configure -state normal
    .txtfrm.txt delete 1.0 end
    .txtfrm.txt configure -state disabled
}

#Procedure to start logging to the log file.  Basically, open the log file and
#set a boolean that says that any input from the connection should
#be logged to the log file
proc startlog {} {
   global config
    if { $config(LOGAPPEND) } { 
        if [catch {open $config(LOGFILENAME) a} Log::logfile] {
             tk_messageBox -icon error -type ok \
                 -message "Could not open log file: $Log::logfile"
             return
        }
    } else { 
        if [catch {open $config(LOGFILENAME) w} Log::logfile] {
             tk_messageBox -icon error -type ok \
                 -message "Could not open log file: $Log::logfile"
             return
        }
    }
    fconfigure $Log::logfile -translation binary
    set Log::logging 1
    .menubar.tools delete 3 
    .menubar.tools insert 3 command -label "Stop Logging (Ctrl-L)" -underline 0 \
    -command { stoplog }

    # Turn the bottom right box background red to indicate logging is on
    .txtbtmlbl configure -bg red1
}

#Procedure to stop logging to the log file.  Basically, close the log file and
#set a boolean that says that any input from the connection ports should
#not be logged to the log file
proc stoplog {} {
    close $Log::logfile
    set Log::logging 0
    .menubar.tools delete 3 
    .menubar.tools insert 3 command -label "Start Logging (Ctrl-L)" -underline 0 \
    -command { startlog }

    # Turn the bottom right box background red to indicate logging is off
    .txtbtmlbl configure -bg [.menubar cget -bg]
}

#This procedure is bound to file-readable events for the the connection.
#Reads in a character at a time and stores them in a global buffer.  At
#
proc get_output {} {
    global SRLFILE

    if { $Script::waitingForIdle } {
        after cancel $Script::waitIdleId
    }
    catch {
        while { ![eof $SRLFILE] } {
            #Ignore \r characters.  Just go with Unix file format.
            set data [read $SRLFILE 1]
            if { $data == "" } break
            if { $data != "\r" } {
                append SR::buf $data
	        if { $Script::waitingForText } {
                    append Script::waitBuffer $data
	            set Script::waitBuffer [string range $Script::waitBuffer "end-$Script::waitTextMaxBufferSize" end]
	        }
            }
        }
    }
    # Only schedule an output handler service routine if one not
    # already scheduled
    if { ! $SR::pending } {
        set SR::pending 1
        after $SR::period { handle_output; set SR::pending 0 }
    }

    if { $Script::waitingForIdle } {
        set Script::waitIdleId [after $Script::waitIdleTime {set Script::waitingForIdle 0; set Script::actionResult done}]
    }
}

# This procedure is the output handerl service routine.  It gets run
# within at most SR::period (100ms) of a character coming
# in over the connection path.  This does the work of displaying the 
# outputin the output buffer and logging the output in the log file 
# (if logging is turned on).

proc handle_output {} {
   global config
   global lastlogchar
    set newline 0
    set scroll_at_bottom \
            [expr { [lindex [.txtfrm.txt yview] 1] >= 1.0 }]
    foreach data [ split $SR::buf {} ] {
        #Log this character if logging turned on
        if { $Log::logging } {
            if { $config(LOGDATE) == 1 && $lastlogchar == "\n" } {
                puts -nonewline $Log::logfile [clock format [clock seconds] -format $config(LOGDATEFORMAT) ]
            }
            puts -nonewline $Log::logfile $data
            set lastlogchar $data
        } 

        # See if this character is a tag start character
        set shouldPrint 1
        if { ! [catch {set curtaginfo $Tag::tagList($data)}] } {
            set shouldPrint 0
            set curtag [lindex $curtaginfo 0]
            # If not already using this tag...
            if { [lsearch $Tag::curTagList $curtag] == -1 } {
                lappend Tag::curTagList $curtag
                lappend Tag::tagStopList([lindex $curtaginfo 1]) $curtag
            }
        }

        # See if this character is a tag end character
        if { ! [catch {set stopList $Tag::tagStopList($data)}] } {
            set shouldPrint 0
            foreach stopTag $stopList {
                set tagIndex [lsearch $Tag::curTagList $stopTag]
                set Tag::curTagList [lreplace $Tag::curTagList $tagIndex $tagIndex]
            } 
            unset Tag::tagStopList($data)
        }

        if { $shouldPrint } {
            if { [ string is ascii $data ] } {
                .txtfrm.txt configure -state normal
                #Special handling if this is the end of a line...
                if {$data == "\n"} {
                    .txtfrm.txt insert end $data
                    set newline 1
                } else {
                    .txtfrm.txt insert end $data $Tag::curTagList
                }
                .txtfrm.txt configure -state disabled
            }
        }

    }

    if { $Log::logging } {
        flush $Log::logfile
    }

    #Maintain the less than the max number of lines
    if { $newline } { 
        .txtfrm.txt configure -state normal
        .txtfrm.txt delete 1.0 end-${config(MAXLINES)}l 
        .txtfrm.txt configure -state disabled
    }

    #Move the buffer view to the end if necessary
    if { $scroll_at_bottom || $config(FOLLOW) } {
         .txtfrm.txt see end
    }


    set SR::buf ""
    
    if { $Script::waitingForText } {
        ScriptCheckForText
    }
}

proc ScriptCheckForText {} {
    set found [regexp "(?q)${Script::waitText}" "$Script::waitBuffer"]
    if { $found } {
        set Script::waitingForText 0
	set Script::waitBuffer ""
	set Script::actionResult done
    }
}

proc readcmdfile {filename} {
   global config defconfig
    set i 0
    if [catch {open $filename r} fileId] {
        if { $filename != $defconfig(COMMANDFILE) } {
            tk_messageBox -icon warning -type ok \
                -message "Could not open command file.\n\n$fileId.\n\nCreating new file."
            if { ! [catch {open $filename w} fileId] } {
                close $fileId
            }
        }
    } else {
        while { [gets $fileId line] >= 0 && $i < $config(MAXCOMMANDS) } {
            set Cmd::entryText($i) $line
            incr i
        }
        while { $i < $config(MAXCOMMANDS) } {
            set Cmd::entryText($i) ""
            incr i
        }

        close $fileId
    }
}

#Procedure to read preset commands from the command file
proc readcmds {} {
   global config CURHIDDEN
    readcmdfile $config(COMMANDFILE)

    set CURHIDDEN $config(HIDDEN)
    if { ! $CURHIDDEN } {
        create_entries $config(NUMCOMMANDS)
    }
}

#Procedure to save preset commands to a new command file
proc savecmdsas {} {
   global config CURHIDDEN
    set newcommandfilename [tk_getSaveFile -title "Select command file" -initialfile $config(COMMANDFILE)]
    if {$newcommandfilename != ""} {
        set config(COMMANDFILE) $newcommandfilename
        set i 0
        if [catch {open $config(COMMANDFILE) w} fileId] {
            tk_messageBox -icon error -type ok \
                -message "Could not open command file: $fileId"
        } else {
            while { $i < [array size Cmd::entryText] } {
                puts $fileId $Cmd::entryText($i)
                incr i
            }
            close $fileId
        }
    }
}

#Procedure to save the current configuration to a configration file
proc saveConfigToFile {} {
    global CONFIGFILENAME
    set newconfigfilename [tk_getSaveFile -title "Select config file" -initialfile $CONFIGFILENAME]
    if {$newconfigfilename != ""} {
        saveConfig $newconfigfilename
    }
}

#Procedure to save preset commands to the command file
proc savecmds {} {
   global config CURHIDDEN
    set i 0
    if [catch {open $config(COMMANDFILE) w} fileId] {
        tk_messageBox -icon error -type ok \
            -message "Could not open command file: $fileId"
    } else {
        while { $i < [array size Cmd::entryText] } {
            puts $fileId $Cmd::entryText($i)
            incr i
        }
        close $fileId
    }
}

##Procedure to go up to previous manual command in the manual command history.
#This is bound to the up arrow in the manual command entry.
proc histup {} {
    if { $Hist::histTail != -1 } {
        if { $Hist::histIndex == -1 } {
            set Hist::histIndex $Hist::histTail
        } else {
            if { $Hist::histIndex != $Hist::histHead } {
                if { $Hist::histIndex == 0} {
                    set Hist::histIndex $Hist::histEnd
                } else {
                    incr Hist::histIndex -1
                }
            }
        }
        .cmdent delete 0 end
        .cmdent insert end $Hist::histList($Hist::histIndex)
    }
}
                
#Procedure to go up to next manual command in the manual command history.
#This is bound to the down arrow in the manual command entry.
proc histdown {} {
    if { $Hist::histTail != -1 } {
        if { $Hist::histIndex != -1 } {
            if {$Hist::histIndex != $Hist::histTail } {
                incr Hist::histIndex
                if { $Hist::histIndex > $Hist::histEnd } {
                    set Hist::histIndex 0
                } 
                .cmdent delete 0 end
                .cmdent insert end $Hist::histList($Hist::histIndex)
            } else {
                set Hist::histIndex -1
                .cmdent delete 0 end
            }
        } 
    }
}

#Procedure to add a new manual command to the manual command history
#This is bound to Return in the manual command entry.
proc addhist cmd {
    if { $cmd != "" } {
        if { $Hist::histHead == -1 } {
            set Hist::histHead 0
            set Hist::histTail 0
            set Hist::histList(0) "$cmd"
        } else {
            if { $cmd != $Hist::histList($Hist::histTail) } {
                if { $Hist::histTail == $Hist::histEnd } {
                    set Hist::histTail 0
                } else {
                    incr Hist::histTail
                }

                if { $Hist::histTail == $Hist::histHead } {
                    if { $Hist::histHead == $Hist::histEnd } {
                        set Hist::histHead 0
                    } else {
                        incr Hist::histHead
                    }
                }
                set Hist::histList($Hist::histTail) "$cmd"
            }
        }
        set Hist::histIndex -1
    }
}

#Procedure to create the preset command entry windows at the top of 
#the main window
proc create_entries {numCmds} {
   global config
    frame .cmdfrm
    for {set i 0} {$i < $numCmds} {incr i} {
        entry .cmdfrm.ent$i -width 40 -bg "${config(BACKGROUND)}" -fg "${config(FOREGROUND)}" \
        -insertbackground "${config(FOREGROUND)}" -selectforeground "${config(BACKGROUND)}" \
        -selectbackground "${config(FOREGROUND)}" \
        -font "${config(TEXTFONT)} ${config(TEXTSIZE)}" -textvariable Cmd::entryText($i)
        button .cmdfrm.rb$i -text "Send" -command "sendcmd $i" -pady 0 -padx 0 \
        -font "helvetica ${config(TEXTSIZE)} bold"
        grid .cmdfrm.rb$i -column 0 -row $i -sticky w
        grid .cmdfrm.ent$i -column 1 -row $i -sticky nsew
        bind .cmdfrm.ent$i <Return> "sendcmd $i"
        bind .cmdfrm.ent$i <Tab> ".cmdfrm.ent$i insert insert \"\\t\"; break"
    }
    grid columnconfigure .cmdfrm 1 -weight 1
    grid .cmdfrm -row 0 -column 0 -sticky nsew
}

proc destroy_commands {} {
   global config
   for {set i 0} {$i < $config(NUMCOMMANDS)} {incr i} {
        destroy .cmdfrm.ent$i .cmdfrm.rb$i
    }
    destroy .cmdfrm
}

#Procedure to redraw the preset command entries
proc set_num_commands num {
    destroy_commands
    set config(NUMCOMMANDS) $num
    create_entries $num
}

#Procedure to toggle hiding the preset command entries
proc toggle_hide_commands {} {
   global config CURHIDDEN
    if { $CURHIDDEN == 0 } { 
        set CURHIDDEN 1
        destroy_commands
    } else { 
        set CURHIDDEN 0
        unhide_commands 
    }
}

#Procedure to hide the preset command entries
proc unhide_commands {} {
   global config
    create_entries $config(NUMCOMMANDS)
}

#Procedure to change buffer scroll bar color when "scroll on activity" toggled
proc new_scroll {} {
   global config
    if { $config(FOLLOW) } {
        .txtfrm.srl_y configure -bg "maroon4"
    } else {
        .txtfrm.srl_y configure -bg [.menubar cget -bg]
    }
}

proc readConfig {config_arg filename} {
    global CONFIGFILENAME D_CONFIGFILENAME defconfig

    upvar $config_arg conf
    if { [catch {open $filename r} configFileId] } {
        if { $filename != $D_CONFIGFILENAME } {
            tk_messageBox -icon error -type ok \
                -message "Could not open config file ${CONFIGFILENAME}: $configFileId"
        }
    } else {
        gets $configFileId line
        if { [catch { array set conf $line } result ] } {
            tk_messageBox -icon error -type ok \
                -message "Configuration file has incorrect format: $configFileId"
        return 1
    }
    set CONFIGFILENAME $filename
    set options [array names defconfig]
    foreach name $options {
        if { [llength [array get conf $name]] == 0 } {
            set conf($name) $defconfig($name)
        }
    }
        close $configFileId
    }
}

proc saveConfig {filename} {
    global temp_config 
    if { [catch {open $filename w} configFileId] } {
        tk_messageBox -icon error -type ok \
            -message "Could not open config file $filename: $configFileId"
    } else {
        puts $configFileId [array get temp_config]
        close $configFileId
    }
}


 ################### Main code body ###################
# Read in arguments
set arglist $argv
set display 1

# first check for a config file
while { [llength $arglist ] } {
    if { [ catch {
            if { [lindex $arglist 0] == "-c" } {
                set CONFIGFILENAME [lindex $arglist 1]
                set arglist [list]
            }
        } errorId] } {
            usage . "$errorId\n" "exit 1"
            set display 0
    }
    set arglist [lrange $arglist 1 end]
}

readConfig config $CONFIGFILENAME

set arglist $argv

while { [llength $arglist ] && $display} {
    set shiftcount 2
    if { [ catch {
            switch -- [lindex $arglist 0] {
                "-c" { }
                "-d" {set config(DEVICE) [lindex $arglist 1] }
                "-n" { 
                    if { [lindex $arglist 1] > $config(MAXCOMMANDS) } { 
                        usage . "Too many command windows!!\n" "exit 1"; set display 0 
                    } else {
                        set config(NUMCOMMANDS) [lindex $arglist 1] 
                    }
                }
                "-f" {set config(COMMANDFILE) [lindex $arglist 1] }
                "-baud" {set config(BAUD) [lindex $arglist 1] }
                "-parity" {set config(PARITY) [lindex $arglist 1] }
                "-datasize" {set config(DATA) [lindex $arglist 1] }
                "-stopbits" {set config(STOP) [lindex $arglist 1] }
                "-fontsize" {set config(TEXTSIZE) [lindex $arglist 1] }
                "-fontfamily" {set config(TEXTFONT) [lindex $arglist 1] }
                "-fg" {
                    set config(FOREGROUND) [lindex $arglist 1] 
                }
                "-bg" {
                    set config(BACKGROUND) [lindex $arglist 1] 
                }
                "-colors" {
                    list_colors . exit
                    set shiftcount 1
                    set display 0
                }
                "-scroll" {
                    set config(FOLLOW) 1 
                    set shiftcount 1
                }
                "-h" {
                    set config(HIDDEN) 1 
                    set shiftcount 1
                }
                "-nowrap" {
                    set config(WRAP) 0 
                    set shiftcount 1
                }
                "-ac" {
                    if { [lindex $arglist 1] == "off" } {
                        set config(AUTOCOMPLETE) 0
                    } elseif { [lindex $arglist 1] == "on" } {
                        set config(AUTOCOMPLETE) 1
                    } else {
                        usage . "Invalid autocomplete value: [lindex $arglist 1]\n" "exit 1"
                        set display 0
                    }
                }
                "-acfile" { set config(AUTOCOMPLETEFILE) [lindex $arglist 1] }
                "-tag" {
                    set taginfo [lindex $arglist 1]
                    if { [regexp {^([^:]+):([^:]+):([^:]*):?([^:]*)$}  $taginfo] } {
                        lappend config(TAGINFO) $taginfo
                    } else {
                        usage . "Invalid tag: $taginfo\n" "exit 1"
                        set display 0
                    }
                }
                default { usage . "Unknown argument: [lindex $arglist 0]\n" "exit 1"; set display 0 }
            }
        } errorId] } {
            usage . "$errorId\n" "exit 1"
            set display 0
    }
    set arglist [lrange $arglist $shiftcount end]
}

proc addTag {taginfo ind} {
   global config
    regexp {^([^:]+):([^:]+):([^:]*):?([^:]*)$}  $taginfo wholematch start stop fg bg
    if {$fg == "reverse"} {
        set fg $config(BACKGROUND)
        set bg $config(FOREGROUND)
    }
    if { $bg == "" } { 
        if {$fg != ""} {
            .txtfrm.txt tag configure tag$ind -foreground $fg
            set Tag::tagList([format "%c" $start]) [list tag$ind [format "%c" $stop]]
        }
    } else {
        if {$fg != ""} {
            .txtfrm.txt tag configure tag$ind -foreground $fg -background $bg
        } else {
            .txtfrm.txt tag configure tag$ind -background $bg
        }
        set Tag::tagList([format "%c" $start]) [list tag$ind [format "%c" $stop]]
    }
}

proc find_text {} {
   global config
    if { ! [catch {selection get -displayof .txtfrm.txt} tempsel] } {
        set Find::tempseltext $tempsel
    } else {
        set Find::tempseltext $Find::seltext
    }

    if { [catch {toplevel .fpop}] } {
        raise .fpop
        if { "$Find::tempseltext" != "" } {
            .fpop.bottomfrm.findnextbtn configure -state normal
            .fpop.bottomfrm.tagallbtn configure -state normal
            focus .fpop.bottomfrm.findnextbtn
        }

        return
    }

    wm title .fpop "Find Text"

    frame .fpop.middlefrm
    label .fpop.middlefrm.dirlbl -text "Search Direction:" -font "helvetica ${config(TEXTSIZE)} bold"
    radiobutton .fpop.middlefrm.downbtn -text "Down" -variable Find::findup -value 0 \
    -font "helvetica ${config(TEXTSIZE)} bold"
    radiobutton .fpop.middlefrm.upbtn -text "Up" -variable Find::findup -value 1 \
    -font "helvetica ${config(TEXTSIZE)} bold"
    checkbutton .fpop.middlefrm.casebtn -text "Ignore Case" -variable Find::ignorecase \
    -font "helvetica ${config(TEXTSIZE)} bold"
    checkbutton .fpop.middlefrm.wordbtn -text "Whole Word" -variable Find::wholeword \
    -font "helvetica ${config(TEXTSIZE)} bold"
    
    frame .fpop.bottomfrm
    button .fpop.bottomfrm.findnextbtn -text "Find Next" -font "helvetica ${config(TEXTSIZE)} bold" \
        -command "find_next" -state disabled
    button .fpop.bottomfrm.tagallbtn -text "Tag All" -font "helvetica ${config(TEXTSIZE)} bold" \
        -command "tag_from_find" -state disabled
    button .fpop.bottomfrm.untagallbtn -text "Clear Tags" -font "helvetica ${config(TEXTSIZE)} bold" \
        -command ".txtfrm.txt tag delete \"tagall\""
    button .fpop.bottomfrm.cancelbtn -text "Cancel" -font "helvetica ${config(TEXTSIZE)} bold" \
        -command ".txtfrm.txt tag delete \"tagfind\"; destroy .fpop"

    frame .fpop.topfrm
    label .fpop.topfrm.findlbl -text "Find : " -font "helvetica ${config(TEXTSIZE)} bold" 
    entry .fpop.topfrm.findent -width 30 -relief sunken \
          -textvariable Find::tempseltext -font "${config(TEXTFONT)} ${config(TEXTSIZE)}" \
          -validate all -validatecommand {validate_findtext %P}

    if { "$Find::tempseltext" != "" } {
        .fpop.bottomfrm.findnextbtn configure -state normal
        .fpop.bottomfrm.tagallbtn configure -state normal
        focus .fpop.bottomfrm.findnextbtn
    }

    grid .fpop.topfrm -row 0 -column 0 -sticky ew
    grid .fpop.topfrm.findlbl -row 0 -column 0
    grid .fpop.topfrm.findent -row 0 -column 1 -sticky ew

    grid .fpop.middlefrm -row 1 -column 0 -sticky ew
    grid .fpop.middlefrm.dirlbl -row 0 -column 0
    grid .fpop.middlefrm.downbtn -row 0 -column 1
    grid .fpop.middlefrm.upbtn -row 0 -column 2 -sticky w
    grid .fpop.middlefrm.casebtn -row 1 -column 1
    grid .fpop.middlefrm.wordbtn -row 1 -column 2 -sticky w

    grid .fpop.bottomfrm -row 3 -column 0 -sticky ew
    grid .fpop.bottomfrm.findnextbtn -row 0 -column 0
    grid .fpop.bottomfrm.tagallbtn -row 0 -column 1
    grid .fpop.bottomfrm.untagallbtn -row 0 -column 2
    grid .fpop.bottomfrm.cancelbtn -row 0 -column 3 -sticky w

    grid columnconfigure .fpop 0 -weight 1
    grid columnconfigure .fpop.topfrm 1 -weight 1
    grid columnconfigure .fpop.middlefrm 2 -weight 1
    grid columnconfigure .fpop.bottomfrm 3 -weight 1

    update
    bind .fpop <Return> {if { "$Find::tempseltext" != "" } { find_next }}
    wm minsize .fpop [winfo width .fpop] [winfo height .fpop]
    wm maxsize .fpop 600 [winfo height .fpop]
    array set geom [getgeom .]
    wm geometry .fpop +$geom(xpos)+$geom(ypos)
    raise .fpop
    if { "$Find::tempseltext" == "" } {
        focus .fpop.topfrm.findent
    }
}

proc getgeom { win } {
    set wingeom [wm geometry $win ]
    scan $wingeom %dx%d+%d+%d width height xpos ypos
    array set geom {}
    set geom(width) $width
    set geom(height) $height
    set geom(xpos) $xpos
    set geom(ypos) $ypos
    return [array get geom]
}

# Tag all text that matches the text specified in the find dialogue
proc tag_from_find {} {
    set Find::seltext "$Find::tempseltext"
    tag_all $Find::seltext $Find::ignorecase $Find::wholeword
}

# Tag all text that matches the currently selected text
proc tag_from_select {} {
    if { ! [catch {selection get -displayof .txtfrm.txt} tempsel] } {
        tag_all $tempsel 0 0
    } else {
        short_display "Text not selected" "Text not selected" 1000
    }
}

# This is the workhorse of the text tagging above
proc tag_all { word ignorecase wholeword } {
   global config
    .txtfrm.txt tag delete "tagall"
    set l1 [string length "$word"]
    scan [.txtfrm.txt index end] %d nl
    set origpos [.txtfrm.txt index insert]
    set curpos "1.0"
    set cl 1
    .txtfrm.txt mark set last $cl.end
    set lpos [.txtfrm.txt index last]
    while {$cl < $nl} {
        if { $ignorecase } {
            if { $wholeword } {
                regsub -all {\W} "$word" {\\&} myreg
                set myregexp "\\m${myreg}\\M"
                set curpos [.txtfrm.txt search -forward -nocase -regexp "$myregexp" $curpos $lpos]
            } else {
                set curpos [.txtfrm.txt search -forward -nocase "$word" $curpos $lpos]
            }
        } else {
            if { $wholeword } {
                regsub -all {\W} "$word" {\\&} myreg
                set myregexp "\\m${myreg}\\M"
                set curpos [.txtfrm.txt search -forward -regexp "$myregexp" $curpos $lpos]
            } else {
                set curpos [.txtfrm.txt search -forward "$word" $curpos $lpos]
            }
        }
        if {$curpos != ""} {
            .txtfrm.txt mark set insert $curpos
            set pos [.txtfrm.txt index "insert + $l1 chars"]
            .txtfrm.txt tag add "tagall" $curpos $pos
            .txtfrm.txt tag configure "tagall" -background $config(FOREGROUND) -foreground $config(BACKGROUND)
            .txtfrm.txt tag lower "tagall"
            .txtfrm.txt mark set insert "insert + $l1 chars"
            set curpos $pos
        } else {
            .txtfrm.txt mark set last "$lpos + 1 line lineend"
            set lpos [.txtfrm.txt index last]
            set curpos [.txtfrm.txt index "$lpos linestart"]
        }
        scan $curpos %d cl
    }
    .txtfrm.txt mark set insert $origpos

}
    
proc validate_findtext {val} {
    if { "$val" != "" } {
        .fpop.bottomfrm.findnextbtn configure -state normal
        .fpop.bottomfrm.tagallbtn configure -state normal
    } else {
        .fpop.bottomfrm.findnextbtn configure -state disabled
        .fpop.bottomfrm.tagallbtn configure -state disabled
    }
    return 1
}

proc find_next {} {
    focus .fpop.bottomfrm.findnextbtn
    set Find::seltext "$Find::tempseltext"
    set l1 [string length "$Find::seltext"]
    if {[string length [.txtfrm.txt get 1.0 end]] < $l1} {
        short_display "Not found!"  "Not found!" 2000
        return
    }
    
    if { $Find::findup == 0 } {
        set origpos [.txtfrm.txt index "insert"]
        if { $Find::ignorecase } {
            if { $Find::wholeword } {
                regsub -all {\W} "$Find::seltext" {\\&} myreg
                set myregexp "\\m${myreg}\\M"
                set curpos [.txtfrm.txt search -forward -nocase -regexp "$myregexp" $origpos end]
            } else {
                set curpos [.txtfrm.txt search -forward -nocase "$Find::seltext" $origpos end]
            }
        } else {
            if { $Find::wholeword } {
                regsub -all {\W} "$Find::seltext" {\\&} myreg
                set myregexp "\\m${myreg}\\M"
                set curpos [.txtfrm.txt search -forward -regexp "$myregexp" $origpos end]
            } else {
                set curpos [.txtfrm.txt search -forward "$Find::seltext" $origpos end]
            }
        }
        if {$curpos != ""} {
            selection clear .txtfrm.txt 
            .txtfrm.txt mark set insert "$curpos + $l1 chars "
            .txtfrm.txt tag delete "tagfind"
            .txtfrm.txt tag add "tagfind" $curpos "$curpos + $l1 chars"
            .txtfrm.txt tag configure "tagfind" -background red
            .txtfrm.txt see $curpos
        } else {
            short_display "Reached bottom.\nSearching from top." \
                          "Reached bottom" 1000
            if { $Find::ignorecase } {
                if { $Find::wholeword } {
                    regsub -all {\W} "$Find::seltext" {\\&} myreg
                    set myregexp "\\m${myreg}\\M"
                    set curpos [.txtfrm.txt search -forward -nocase -regexp "$myregexp" "1.0" $origpos]
                } else {
                    set curpos [.txtfrm.txt search -forward -nocase "$Find::seltext" "1.0" $origpos]
                }
            } else {
                if { $Find::wholeword } {
                    regsub -all {\W} "$Find::seltext" {\\&} myreg
                    set myregexp "\\m${myreg}\\M"
                    set curpos [.txtfrm.txt search -forward -regexp "$myregexp" "1.0" $origpos]
                } else {
                    set curpos [.txtfrm.txt search -forward "$Find::seltext" "1.0" $origpos]
                }
            }
            if {$curpos != ""} {
                selection clear .txtfrm.txt 
                .txtfrm.txt mark set insert "$curpos + $l1 chars "
                .txtfrm.txt tag delete "tagfind"
                .txtfrm.txt tag add "tagfind" $curpos "$curpos + $l1 chars"
                .txtfrm.txt tag configure "tagfind" -background red
                .txtfrm.txt see $curpos
            } else {
                short_display "Text not found!"  "Not found!" 1500
            }
        }
    } else {
        set origpos [.txtfrm.txt index "insert - $l1 chars"]
        if { $Find::ignorecase } {
            if { $Find::wholeword } {
                regsub -all {\W} "$Find::seltext" {\\&} myreg
                set myregexp "\\m${myreg}\\M"
                set curpos [.txtfrm.txt search -backward -nocase -regexp "$myregexp" $origpos "1.0"]
            } else {
                set curpos [.txtfrm.txt search -backward -nocase "$Find::seltext" $origpos "1.0"]
            }
        } else {
            if { $Find::wholeword } {
                regsub -all {\W} "$Find::seltext" {\\&} myreg
                set myregexp "\\m${myreg}\\M"
                set curpos [.txtfrm.txt search -backward -regexp "$myregexp" $origpos "1.0"]
            } else {
                set curpos [.txtfrm.txt search -backward "$Find::seltext" $origpos "1.0"]
            }
        }
        if {$curpos != ""} {
            selection clear .txtfrm.txt 
            .txtfrm.txt mark set insert "$curpos + $l1 chars "
            .txtfrm.txt tag delete "tagfind"
            .txtfrm.txt tag add "tagfind" $curpos "$curpos + $l1 chars"
            .txtfrm.txt tag configure "tagfind" -background red
            .txtfrm.txt see $curpos
        } else {
            short_display "Reached top.\nSearching from bottom." \
                          "Reached top" 1000
            if { $Find::ignorecase } {
                if { $Find::wholeword } {
                    regsub -all {\W} "$Find::seltext" {\\&} myreg
                    set myregexp "\\m${myreg}\\M"
                    set curpos [.txtfrm.txt search -backward -nocase -regexp "$myregexp" end $origpos]
                } else {
                    set curpos [.txtfrm.txt search -backward -nocase "$Find::seltext" end $origpos]
                }
            } else {
                if { $Find::wholeword } {
                    regsub -all {\W} "$Find::seltext" {\\&} myreg
                    set myregexp "\\m${myreg}\\M"
                    set curpos [.txtfrm.txt search -backward -regexp "$myregexp" end $origpos]
                } else {
                    set curpos [.txtfrm.txt search -backward "$Find::seltext" end $origpos]
                }
            }
            if {$curpos != ""} {
                selection clear .txtfrm.txt 
                .txtfrm.txt mark set insert "$curpos + $l1 chars "
                .txtfrm.txt tag delete "tagfind"
                .txtfrm.txt tag add "tagfind" $curpos "$curpos + $l1 chars"
                .txtfrm.txt tag configure "tagfind" -background red
                .txtfrm.txt see $curpos
            } else {
                short_display "Text not found!"  "Not found!" 1500
            }
        }

    }
}

proc short_display { disp_text disp_title num_ms } {
    toplevel .disp
    wm title .disp $disp_title
    wm minsize .disp 200 100
    label .disp.label -text $disp_text -font "helvetica 10 bold" -fg black -bg red
    grid .disp.label -row 0 -column 0 -sticky nsew
    grid columnconfigure .disp 0 -weight 1
    grid rowconfigure .disp 0 -weight 1
    array set geom [getgeom .]
    wm geometry .disp +$geom(xpos)+$geom(ypos)
    grab .disp
    wm transient .disp
    set x 0
    after $num_ms "destroy .disp; set x 1"
    vwait x
}

proc check_focus { char_in } {
    if { [ string is print -strict $char_in ] } {
        .cmdent insert insert $char_in
        focus .cmdent 
    } elseif { $char_in == "\n" || $char_in == "\r" } {
        send_cmd_entry_cmd
    }
}

proc send_cmd_entry_cmd {} {
   global config
    set cmd [.cmdent get]
    set value 1
    send "$cmd"
    addhist "$cmd"
    .cmdent delete 0 end
    if { "$cmd" != "" && [string first \n "$cmd"] == -1 } { 
        set matchValue [ string map { "\*" "\\*" "\?" "\\?" "\[" "\\[" "\]" "\\]" "\\" "\\\\" } "$cmd" ]
        set matchList [ array get Hist::autoCompleteList "$matchValue" ]
        if { [ llength $matchList ] } {
            set value [expr { [lindex $matchList 1] + 1 }]
            set Hist::autoCompleteList($cmd) $value
        } else {
            set Hist::autoCompleteList($cmd) 1
        }
        if { [array size Hist::autoCompleteList] >= $config(AC_MAX) } {
            trim_autocomplete
            # Put the last command back in if it was removed
            if { $value == 1 } {
                set Hist::autoCompleteList($cmd) $value
            }
        }
        if { $config(AUTOCOMPLETEFILE) != "none" && ! \
            [catch {open $config(AUTOCOMPLETEFILE) w} acFileId] } {
            puts $acFileId [array get Hist::autoCompleteList]
            close $acFileId
        }
    }
} 

proc reset_tags {} {
    set Tag::curTagList {}
    array set Tag::tagStopList {}
}

proc open_connection {config_arg} {
    global SRLFILE display
    #Now attempt to open the connection
    #First see if we're connecting via a socket or serial
    upvar $config_arg conf
    set dev "$conf(DEVICE)"
    set connectmode serial
    if { ![ string compare -nocase -length 3 $dev "com" ] && \
         [ string length $dev ] == 4 } {
        set dev "${dev}:"
    } elseif { [string index $dev 0 ] != "/" } {  
        set connectmode net
        if { ![regexp {^([^:]+):([\d]+)$} $dev wholematch host port] } {
            set host $dev
            set port 7435
        }
    }

    set connect_error 0
    if { $connectmode == "net" } {
        # Open socket and configure it
        if [catch {socket $host $port} SRLFILE] {
            tk_messageBox -icon error -type ok \
                -message "Could not open network connection to $conf(DEVICE): $SRLFILE"
            set connect_error 1
        } elseif [catch {fconfigure $SRLFILE -blocking 0 \
                                       -translation binary \
                                       -buffering none} errorId] {
            #An error probably means the user entered bad arguments
            tk_messageBox -icon error -type ok \
                -message "Invalid connection settings specified: $errorId"
            set connect_error 1
        }
    } else {
        # Open serial device file and configure it

        if [catch {open $dev {RDWR NONBLOCK}} SRLFILE] {
            tk_messageBox -icon error -type ok \
                -message "$SRLFILE"
            set connect_error 1
        } else {

            set conf_string [fconfigure $SRLFILE]
            if { [string first "-mode" "$conf_string"] == -1 } {
                tk_messageBox -icon error -type ok \
                    -message "\"$dev\" not recognized as a valid serial device on this system!"
                 set connect_error 1
            }
        }
            
        if { $connect_error == 0 } {
            #Configure the device file using the baud, parity, ...
            set conf_string "fconfigure $SRLFILE -blocking 0 -mode $conf(BAUD),$conf(PARITY),$conf(DATA),$conf(STOP) -translation binary -buffering none"
            if [expr {[string range [info tclversion] 0 2] >= 8.4} ] { append conf_string " -handshake none" }
    
            if [catch {eval $conf_string} errorId] {
                #An error probably means the user entered bad arguments
                tk_messageBox -icon error -type ok \
                        -message "Invalid terminal settings specified: $errorId"
                set connect_error 1
            }
        }
    }

    if { $connect_error == 1 } {
        wm title . "$conf(SCRIPTNAME) - NOT CONNECTED!"
    } else {
        wm title . "$conf(SCRIPTNAME) - $conf(DEVICE)"
        #bind file readable events to the get_output procedure
        fileevent $SRLFILE readable get_output
    }

    return $connect_error
}

if {$display} {
    # We're not just displaying the usage or list of colors, so
    # create the main window GUI
    # First create the menus
    if [catch {file mkdir [file dirname $config(COMMANDFILE) ]} errorID]  {
        tk_messageBox -icon error -type ok \
            -message "Error creating command file!!\n$errorID "
        exit 1
    }
        
    if [catch {file mkdir [file dirname $config(AUTOCOMPLETEFILE) ]} errorID]  {
        tk_messageBox -icon error -type ok \
            -message "Error creating autocomplete file!!\n$errorID "
        exit 1
    }
}

proc set_min_size_to_natural_size {win} {
    #wm geometry $win
    #update
    #wm minsize $win [winfo width $win] [winfo height $win]
}

proc set_specific_option {force} {
    global curoption

    if { $force } {
        set selected_index $curoption
    } else {
        set selected_index [lindex [.f_options.f_main.f_chooser.lb_chooser curselection] 0]
    }
    if { $selected_index != $curoption || $force } {
        destroy_specific_options_window
        switch -- $selected_index {
            0 {window_options}
        1 {command_options}
        2 {connection_options}
        3 {logging_options}
        4 {advanced_options}
        }
    set curoption $selected_index
    }
}

proc destroy_windows {win} {
    foreach w [winfo children $win] {
        destroy_windows $w
    }
    destroy $win
}

proc destroy_specific_options_window {} {
    destroy_windows .f_options.f_main.f_specific
    frame .f_options.f_main.f_specific
    grid .f_options.f_main.f_specific -row 0 -column 1 -sticky nsew
    grid columnconfigure .f_options.f_main 1 -weight 1
    grid rowconfigure .f_options.f_main 1 -weight 1
}
proc change_bg_color {} {
    global temp_config

    set color [tk_chooseColor -initialcolor ${temp_config(BACKGROUND)}]
    if { $color != "" } {
        set temp_config(BACKGROUND) $color
        .f_options.f_main.f_specific.f_bg_color.c_color configure -bg ${temp_config(BACKGROUND)}
    } 
}

proc change_fg_color {} {
    global temp_config

    set color [tk_chooseColor -initialcolor ${temp_config(FOREGROUND)}]
    if { $color != "" } {
        set temp_config(FOREGROUND) $color
        .f_options.f_main.f_specific.f_fg_color.c_color configure -bg ${temp_config(FOREGROUND)}
    } 
}

proc window_options {} {
   global cur_font_size
   global temp_config
   global fonts
   
   wm title .f_options "Window options"

   grid columnconfigure .f_options.f_main.f_specific 0 -weight 1

   #Background color
   frame .f_options.f_main.f_specific.f_bg_color
   label .f_options.f_main.f_specific.f_bg_color.l_color -text "Background color:" \
       -font "helvetica $cur_font_size bold"
   canvas .f_options.f_main.f_specific.f_bg_color.c_color \
       -height [expr 1.5 * ${cur_font_size}]p \
       -width [expr 2 * ${cur_font_size}]p \
       -bg ${temp_config(BACKGROUND)} \
       -relief sunken -bd 1p
   button .f_options.f_main.f_specific.f_bg_color.b_color \
       -text "Change" -command change_bg_color
   grid .f_options.f_main.f_specific.f_bg_color -row 0 -sticky new
   grid .f_options.f_main.f_specific.f_bg_color.l_color -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_bg_color.c_color -row 0 -column 1 -sticky new
   grid .f_options.f_main.f_specific.f_bg_color.b_color -row 0 -column 2 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_bg_color 2 -weight 1

   #Foreground color
   frame .f_options.f_main.f_specific.f_fg_color
   label .f_options.f_main.f_specific.f_fg_color.l_color -text "Foreground color:" \
       -font "helvetica $cur_font_size bold"
   canvas .f_options.f_main.f_specific.f_fg_color.c_color \
       -height [expr 1.5 * ${cur_font_size}]p \
       -width [expr 2 * ${cur_font_size}]p \
       -bg ${temp_config(FOREGROUND)} \
       -relief sunken -bd 1p
   button .f_options.f_main.f_specific.f_fg_color.b_color \
       -text "Change" -command change_fg_color
   grid .f_options.f_main.f_specific.f_fg_color -row 1 -sticky new
   grid .f_options.f_main.f_specific.f_fg_color.l_color -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_fg_color.c_color -row 0 -column 1 -sticky new
   grid .f_options.f_main.f_specific.f_fg_color.b_color -row 0 -column 2 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_fg_color 2 -weight 1

   #Font size
   frame .f_options.f_main.f_specific.f_font_size
   label .f_options.f_main.f_specific.f_font_size.l_size -text "Font size:" \
       -font "helvetica $cur_font_size bold"
   tk_optionMenu .f_options.f_main.f_specific.f_font_size.om_size temp_config(TEXTSIZE) 6 7 8 9 10 11 12 14 16 18
   grid .f_options.f_main.f_specific.f_font_size -row 2 -sticky new
   grid .f_options.f_main.f_specific.f_font_size.l_size -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_font_size.om_size -row 0 -column 1 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_font_size 2 -weight 1

   #Font type
   frame .f_options.f_main.f_specific.f_font_type
   label .f_options.f_main.f_specific.f_font_type.l_type -text "Font type:" \
       -font "helvetica $cur_font_size bold"
   listbox .f_options.f_main.f_specific.f_font_type.lb_type -width 25 -height 5 -font "helvetica $cur_font_size" -yscrollcommand ".f_options.f_main.f_specific.f_font_type.s_type set" -selectmode single
   set i 0
   foreach fonttype $fonts {
       .f_options.f_main.f_specific.f_font_type.lb_type insert end $fonttype
       if { [string equal -nocase $fonttype $temp_config(TEXTFONT)] } {
           .f_options.f_main.f_specific.f_font_type.lb_type selection set $i
           .f_options.f_main.f_specific.f_font_type.lb_type yview moveto [expr $i / ($i + 1.0)]
       } else {
       incr i
       }
   }
   scrollbar .f_options.f_main.f_specific.f_font_type.s_type -orient v -command ".f_options.f_main.f_specific.f_font_type.lb_type yview"

   bind .f_options.f_main.f_specific.f_font_type.lb_type <<ListboxSelect>> \
   { set temp_config(TEXTFONT) [lindex $fonts [lindex [.f_options.f_main.f_specific.f_font_type.lb_type curselection] 0]] }

   grid .f_options.f_main.f_specific.f_font_type -row 3 -sticky new
   grid .f_options.f_main.f_specific.f_font_type.l_type -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_font_type.lb_type -row 0 -column 1 -sticky new
   grid .f_options.f_main.f_specific.f_font_type.s_type -row 0 -column 2 -sticky nsew
   grid columnconfigure .f_options.f_main.f_specific.f_font_type 1 -weight 1 

   # Max number of buffer lines
   frame .f_options.f_main.f_specific.f_buf_lines
   label .f_options.f_main.f_specific.f_buf_lines.l_buf_lines -text "Number of buffer lines (May affect performance!!):" \
       -font "helvetica $cur_font_size bold"
   entry .f_options.f_main.f_specific.f_buf_lines.e_buf_lines -width 6 \
       -text ${temp_config(MAXLINES)} \
       -font "helvetica $cur_font_size" \
       -textvariable temp_config(MAXLINES) \
       -validate all -validatecommand { string is digit %P }
   grid .f_options.f_main.f_specific.f_buf_lines -row 4 -sticky new
   grid .f_options.f_main.f_specific.f_buf_lines.l_buf_lines -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_buf_lines.e_buf_lines -row 0 -column 1 -sticky new
   grid columnconfigure .f_options.f_main.f_specific.f_buf_lines 1 -weight 1

   # Always scroll at bottom
   frame .f_options.f_main.f_specific.f_scroll
   label .f_options.f_main.f_specific.f_scroll.l_scroll -text "Go to bottom when data received:" \
       -font "helvetica $cur_font_size bold"
   checkbutton .f_options.f_main.f_specific.f_scroll.cb_scroll -onvalue 1 -offvalue 0 -variable temp_config(FOLLOW)
   grid .f_options.f_main.f_specific.f_scroll -row 5 -sticky new
   grid .f_options.f_main.f_specific.f_scroll.l_scroll -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_scroll.cb_scroll -row 0 -column 1 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_scroll 1 -weight 1

   # Wrap lines
   frame .f_options.f_main.f_specific.f_wrap
   label .f_options.f_main.f_specific.f_wrap.l_wrap -text "Wrap lines:" \
       -font "helvetica $cur_font_size bold"
   checkbutton .f_options.f_main.f_specific.f_wrap.cb_wrap -onvalue 1 -offvalue 0 -variable temp_config(WRAP)
   grid .f_options.f_main.f_specific.f_wrap -row 6 -sticky new
   grid .f_options.f_main.f_specific.f_wrap.l_wrap -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_wrap.cb_wrap -row 0 -column 1 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_wrap 1 -weight 1
   grid rowconfigure .f_options.f_main.f_specific 6 -weight 1
   grid rowconfigure .f_options.f_main.f_specific.f_wrap 0 -weight 1

   set_min_size_to_natural_size .f_options
}

proc browse_command_file {} {
    global temp_config
    set file_name [tk_getOpenFile -title "Choose command file name" -initialfile $temp_config(COMMANDFILE)]
    if {$file_name != ""} {
        set temp_config(COMMANDFILE) $file_name
    }
}

proc browse_ac_file {} {
    global temp_config
    set file_name [tk_getSaveFile -title "Choose autocompletion history file name" -initialfile $temp_config(AUTOCOMPLETEFILE)]
    if {$file_name != ""} {
        set temp_config(AUTOCOMPLETEFILE) $file_name
    }
}

proc toggle_ac_file_entry_enabled {} { 
   global temp_config
   if { $temp_config(AUTOCOMPLETE) == 1 } {
     .f_options.f_main.f_specific.f_ac_file.e_ac_file configure -state disabled
     .f_options.f_main.f_specific.f_ac_file.b_ac_file configure -state disabled
   } else {
     .f_options.f_main.f_specific.f_ac_file.e_ac_file configure -state normal
     .f_options.f_main.f_specific.f_ac_file.b_ac_file configure -state normal
   }
}

proc command_options {} {
   global cur_font_size
   global temp_config

   wm title .f_options "Command options"

   grid columnconfigure .f_options.f_main.f_specific 0 -weight 1

   # Number of command entries
   frame .f_options.f_main.f_specific.f_com_ent
   label .f_options.f_main.f_specific.f_com_ent.l_com_ent \
       -text "Number of preset command entries: " \
       -font "helvetica $cur_font_size bold"
   tk_optionMenu .f_options.f_main.f_specific.f_com_ent.om_com_ent temp_config(NUMCOMMANDS) 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
    
   grid .f_options.f_main.f_specific.f_com_ent -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_com_ent.l_com_ent -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_com_ent.om_com_ent -row 0 -column 1 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_com_ent 1 -weight 1

   # Preset command entries visible on startup
   frame .f_options.f_main.f_specific.f_com_ent_vis
   label .f_options.f_main.f_specific.f_com_ent_vis.l_com_ent_vis -text "Preset command entries visible on startup:" \
       -font "helvetica $cur_font_size bold"
   checkbutton .f_options.f_main.f_specific.f_com_ent_vis.cb_com_ent_vis -onvalue 0 -offvalue 1 -variable temp_config(HIDDEN)
   grid .f_options.f_main.f_specific.f_com_ent_vis -row 1 -sticky new
   grid .f_options.f_main.f_specific.f_com_ent_vis.l_com_ent_vis -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_com_ent_vis.cb_com_ent_vis -row 0 -column 1 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_com_ent_vis 1 -weight 1

   # Preset command file
   frame .f_options.f_main.f_specific.f_com_file
   label .f_options.f_main.f_specific.f_com_file.l_com_file \
       -text "Preset command file: " \
       -font "helvetica $cur_font_size bold"
   entry .f_options.f_main.f_specific.f_com_file.e_com_file -width 30 \
       -text ${temp_config(COMMANDFILE)} \
       -font "helvetica $cur_font_size" \
       -textvariable temp_config(COMMANDFILE)
   button .f_options.f_main.f_specific.f_com_file.b_com_file \
       -text "Browse" -command browse_command_file

   grid .f_options.f_main.f_specific.f_com_file -row 2 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_com_file.l_com_file -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_com_file.e_com_file -row 0 -column 1 -sticky new
   grid .f_options.f_main.f_specific.f_com_file.b_com_file -row 0 -column 2 -sticky new
   grid columnconfigure .f_options.f_main.f_specific.f_com_file 1 -weight 1
   grid rowconfigure .f_options.f_main.f_specific 2 -weight 1

   # Command autocompletion
   frame .f_options.f_main.f_specific.f_autocomplete
   label .f_options.f_main.f_specific.f_autocomplete.l_autocomplete -text "Auto-complete manually entered commands:" \
       -font "helvetica $cur_font_size bold"
   checkbutton .f_options.f_main.f_specific.f_autocomplete.cb_autocomplete -onvalue 1 -offvalue 0 -variable temp_config(AUTOCOMPLETE)
   grid .f_options.f_main.f_specific.f_autocomplete -row 3 -sticky new
   grid .f_options.f_main.f_specific.f_autocomplete.l_autocomplete -row 0 -column 0 -sticky ne 
   grid .f_options.f_main.f_specific.f_autocomplete.cb_autocomplete -row 0 -column 1 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_autocomplete 1 -weight 1

   bind .f_options.f_main.f_specific.f_autocomplete.cb_autocomplete <ButtonPress>  toggle_ac_file_entry_enabled
   bind .f_options.f_main.f_specific.f_autocomplete.cb_autocomplete <Key>  { if { %K == "space" } { toggle_ac_file_entry_enabled } }

   # Autocompletion history file
   frame .f_options.f_main.f_specific.f_ac_file
   label .f_options.f_main.f_specific.f_ac_file.l_ac_file \
       -text "Autocompletion history file: " \
       -font "helvetica $cur_font_size bold"
   entry .f_options.f_main.f_specific.f_ac_file.e_ac_file -width 30 \
       -text ${temp_config(AUTOCOMPLETEFILE)} \
       -font "helvetica $cur_font_size" \
       -textvariable temp_config(AUTOCOMPLETEFILE)
   button .f_options.f_main.f_specific.f_ac_file.b_ac_file \
       -text "Browse" -command browse_ac_file
    
   grid .f_options.f_main.f_specific.f_ac_file -row 4 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_ac_file.l_ac_file -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_ac_file.e_ac_file -row 0 -column 1 -sticky new
   grid .f_options.f_main.f_specific.f_ac_file.b_ac_file -row 0 -column 2 -sticky new
   grid columnconfigure .f_options.f_main.f_specific.f_ac_file 1 -weight 1

   if { $temp_config(AUTOCOMPLETE) == 0 } {
     .f_options.f_main.f_specific.f_ac_file.e_ac_file configure -state disabled
     .f_options.f_main.f_specific.f_ac_file.b_ac_file configure -state disabled
   } else {
     .f_options.f_main.f_specific.f_ac_file.e_ac_file configure -state normal
     .f_options.f_main.f_specific.f_ac_file.b_ac_file configure -state normal
   }

   set_min_size_to_natural_size .f_options
}

proc connection_path_format_help {} {
    toplevel .connection_format_help 
    show_text .connection_format_help \
    "The connection_path can either be the full device file name
for a serial port (e.g. com1, com2, ... on Windows or 
/dev/ttyS0, /dev/ttyS1, ...  on Linux), or if connecting through
a TCP socket, the host name or IP address and port number
separated by a colon (e.g. 111.111.111.111:1234, localhost:80).
The port and its preceding colon may be omitted, in which case
the default port is 7435." \
    {grab release .connection_format_help;destroy .connection_format_help}            
    grab .connection_format_help
    wm transient .connection_format_help
}

proc connection_options {} {
   global cur_font_size
   global temp_config

   wm title .f_options "Connection options"

   grid columnconfigure .f_options.f_main.f_specific 0 -weight 1

   # Connection Path
   frame .f_options.f_main.f_specific.f_c_path
   label .f_options.f_main.f_specific.f_c_path.l_c_path \
       -text "Connection path:" \
       -font "helvetica $cur_font_size bold"
   entry .f_options.f_main.f_specific.f_c_path.e_c_path \
       -text ${temp_config(DEVICE)} \
       -font "helvetica $cur_font_size" \
       -textvariable temp_config(DEVICE)
   button .f_options.f_main.f_specific.f_c_path.b_c_path -width 2 \
       -text "?" -command connection_path_format_help\
       -font "helvetica $cur_font_size"
    
   grid .f_options.f_main.f_specific.f_c_path -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_c_path.l_c_path -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_c_path.e_c_path -row 0 -column 1 -sticky new
   grid .f_options.f_main.f_specific.f_c_path.b_c_path -row 0 -column 2 -sticky new
   grid columnconfigure .f_options.f_main.f_specific.f_c_path 1 -weight 1

   #Baud Rate
   frame .f_options.f_main.f_specific.f_baud
   label .f_options.f_main.f_specific.f_baud.l_baud -text "Baud rate (ignored for network connections):" \
       -font "helvetica $cur_font_size bold"
   entry .f_options.f_main.f_specific.f_baud.e_baud -width 6 \
       -text ${temp_config(BAUD)} \
       -font "helvetica $cur_font_size" \
       -textvariable temp_config(BAUD)
   grid .f_options.f_main.f_specific.f_baud -row 2 -sticky new
   grid .f_options.f_main.f_specific.f_baud.l_baud -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_baud.e_baud -row 0 -column 1 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_baud 1 -weight 1

   # Data size
   frame .f_options.f_main.f_specific.f_datasize
   label .f_options.f_main.f_specific.f_datasize.l_size -text "Data size (ignored for network connections):" \
       -font "helvetica $cur_font_size bold"
   tk_optionMenu .f_options.f_main.f_specific.f_datasize.om_size temp_config(DATA) 5 6 7 8
   grid .f_options.f_main.f_specific.f_datasize -row 3 -sticky new
   grid .f_options.f_main.f_specific.f_datasize.l_size -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_datasize.om_size -row 0 -column 1 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_datasize 1 -weight 1

   # parity
   frame .f_options.f_main.f_specific.f_parity
   label .f_options.f_main.f_specific.f_parity.l_parity -text "Parity (ignored for network connections):" \
       -font "helvetica $cur_font_size bold"
   set paritymenu [tk_optionMenu .f_options.f_main.f_specific.f_parity.om_parity dummy none odd even mark space]
   $paritymenu entryconfigure 0 -command {set temp_config(PARITY) n}
   $paritymenu entryconfigure 1 -command {set temp_config(PARITY) o}
   $paritymenu entryconfigure 2 -command {set temp_config(PARITY) e}
   $paritymenu entryconfigure 3 -command {set temp_config(PARITY) m}
   $paritymenu entryconfigure 4 -command {set temp_config(PARITY) s}
   grid .f_options.f_main.f_specific.f_parity -row 4 -sticky new
   grid .f_options.f_main.f_specific.f_parity.l_parity -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_parity.om_parity -row 0 -column 1 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_parity 1 -weight 1

   # stop bits
   frame .f_options.f_main.f_specific.f_stop
   label .f_options.f_main.f_specific.f_stop.l_stop -text "Stop bits (ignored for network connections):" \
       -font "helvetica $cur_font_size bold"
   tk_optionMenu .f_options.f_main.f_specific.f_stop.om_stop temp_config(STOP) 1 2
   grid .f_options.f_main.f_specific.f_stop -row 5 -sticky new
   grid .f_options.f_main.f_specific.f_stop.l_stop -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_stop.om_stop -row 0 -column 1 -sticky nw
   grid columnconfigure .f_options.f_main.f_specific.f_stop 1 -weight 1
   grid rowconfigure .f_options.f_main.f_specific.f_stop 0 -weight 1
   grid rowconfigure .f_options.f_main.f_specific 5 -weight 1

   set_min_size_to_natural_size .f_options
}

proc browse_log_file {} {
    global temp_config
    set file_name [tk_getSaveFile -title "Choose log file name" -initialfile $temp_config(LOGFILENAME)]
    if {$file_name != ""} {
        set temp_config(LOGFILENAME) $file_name
    }
}
proc logging_date_format_help {} {
    toplevel .logging_date_format_help; 
    show_text .logging_date_format_help \
    "The date format is specified as field descriptors.  Field
descriptors consist of a % followed by a field descriptor 
character. All other characters are copied into the result.
Valid field descriptors are: 
    %% 
        Insert a %. 
    %a 
        Abbreviated weekday name (Mon, Tue, etc.). 
    %A 
        Full weekday name (Monday, Tuesday, etc.). 
    %b 
        Abbreviated month name (Jan, Feb, etc.). 
    %B 
        Full month name. 
    %c 
        Locale specific date and time. The format for date and
           time in the default \"C\" locale on Unix/Mac is 
    \"%a %b %d %H:%M:%S %Y\". On Windows, this value is the 
    locale specific long date and time, as specified in the
           Regional Options control panel settings. 
    %C 
        First two digits of the four-digit year (19 or 20). 
    %d 
        Day of month (01 - 31). 
    %D 
        Date as %m/%d/%y. 
    %e 
        Day of month (1 - 31), no leading zeros. 
    %g 
        The ISO8601 year number corresponding to the ISO8601 
    week (%V), expressed as a two-digit year-of-the-century,
           with leading zero if necessary. 
    %G 
        The ISO8601 year number corresponding to the ISO8601 week
           (%V), expressed as a four-digit number. 
    %h 
        Abbreviated month name. 
    %H 
        Hour in 24-hour format (00 - 23). 
    %I 
        Hour in 12-hour format (01 - 12). 
    %j 
        Day of year (001 - 366). 
    %k 
        Hour in 24-hour format, without leading zeros (0 - 23). 
    %l 
        Hour in 12-hour format, without leading zeros (1 - 12). 
    %m 
        Month number (01 - 12). 
    %M 
        Minute (00 - 59). 
    %n 
        Insert a newline. 
    %p 
        AM/PM indicator. 
    %r 
        Time in a locale-specific \"meridian\" format. The 
    \"meridian\" format in the default \"C\" locale is 
    \"%I:%M:%S %p\". 
    %R 
        Time as %H:%M. 
    %s 
        Count of seconds since the epoch, expressed as a 
    decimal integer. 
    %S 
        Seconds (00 - 59). 
    %t 
        Insert a tab. 
    %T 
        Time as %H:%M:%S. 
    %u 
        Weekday number (Monday = 1, Sunday = 7). 
    %U 
        Week of year (00 - 52), Sunday is the first day of the week. 
    %V 
        Week of year according to ISO-8601 rules. Week 1 of 
    a given year is the week containing 4 January. 
    %w 
        Weekday number (Sunday = 0, Saturday = 6). 
    %W 
        Week of year (00 - 52), Monday is the first day of the week. 
    %x 
        Locale specific date format. The format for a date in the 
    default \"C\" locale for Unix/Mac is \"%m/%d/%y\". On Windows,
           this value is the locale specific short date format, as 
    specified in the Regional Options control panel settings. 
    %X 
        Locale specific 24-hour time format. The format for a 
    24-hour time in the default \"C\" locale for Unix/Mac is
           \"%H:%M:%S\". On Windows, this value is the locale specific
           time format, as specified in the Regional Options control 
    panel settings. 
    %y 
        Year without century (00 - 99). 
    %Y 
        Year with century (e.g. 1990) 
    %Z 
        Time zone name. 
" {grab release .logging_date_format_help;destroy .logging_date_format_help}            
    grab .logging_date_format_help
    wm transient .logging_date_format_help
}

proc logging_options {} {
   global cur_font_size
   global temp_config
   global log_date_state

   wm title .f_options "Logging options"

   # Log file
   frame .f_options.f_main.f_specific.f_log_file
   label .f_options.f_main.f_specific.f_log_file.l_log_file \
       -text "Log file: " \
       -font "helvetica $cur_font_size bold"
   entry .f_options.f_main.f_specific.f_log_file.e_log_file \
       -text ${temp_config(LOGFILENAME)} \
       -font "helvetica $cur_font_size" \
       -textvariable temp_config(LOGFILENAME)
   button .f_options.f_main.f_specific.f_log_file.b_log_file \
       -text "Browse" -command browse_log_file
    
   grid .f_options.f_main.f_specific.f_log_file -row 0 -column 0 -sticky ew
   grid .f_options.f_main.f_specific.f_log_file.l_log_file -row 0 -column 0
   grid .f_options.f_main.f_specific.f_log_file.e_log_file -row 0 -column 1 -sticky ew
   grid .f_options.f_main.f_specific.f_log_file.b_log_file -row 0 -column 2
   grid columnconfigure .f_options.f_main.f_specific 0 -weight 1
   grid columnconfigure .f_options.f_main.f_specific.f_log_file 1 -weight 1

   # Append to logfile
   frame .f_options.f_main.f_specific.f_log_append
   label .f_options.f_main.f_specific.f_log_append.l_log_append \
       -text "Append to existing log file: " \
       -font "helvetica $cur_font_size bold"
   checkbutton .f_options.f_main.f_specific.f_log_append.cb_log_append -onvalue 1 -offvalue 0 -variable temp_config(LOGAPPEND)

   grid .f_options.f_main.f_specific.f_log_append -row 1 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_log_append.l_log_append -row 0 -column 0 -sticky w
   grid .f_options.f_main.f_specific.f_log_append.cb_log_append -row 0 -column 1 -sticky w
   grid columnconfigure .f_options.f_main.f_specific.f_log_append 1 -weight 1

   # Log date
   frame .f_options.f_main.f_specific.f_log_date
   label .f_options.f_main.f_specific.f_log_date.l_log_date \
       -text "Prepend log file lines with date/time: " \
       -font "helvetica $cur_font_size bold"
   checkbutton .f_options.f_main.f_specific.f_log_date.cb_log_date -onvalue 1 -offvalue 0 -variable log_date_state
   frame .f_options.f_main.f_specific.f_log_date_format
   label .f_options.f_main.f_specific.f_log_date_format.l_format \
       -text "Date/time format: " \
       -font "helvetica $cur_font_size bold"
   entry .f_options.f_main.f_specific.f_log_date_format.e_format \
       -text ${temp_config(LOGDATEFORMAT)} \
       -font "helvetica $cur_font_size" \
       -textvariable temp_config(LOGDATEFORMAT)
   button .f_options.f_main.f_specific.f_log_date_format.b_format -width 2 \
       -text "?" -command logging_date_format_help\
       -font "helvetica $cur_font_size"

   bind .f_options.f_main.f_specific.f_log_date.cb_log_date <ButtonPress> log_date_toggle

   grid .f_options.f_main.f_specific.f_log_date -row 2 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_log_date.l_log_date -row 0 -column 0 -sticky w
   grid .f_options.f_main.f_specific.f_log_date.cb_log_date -row 0 -column 1 -sticky w
   grid columnconfigure .f_options.f_main.f_specific.f_log_date 1 -weight 1

   grid .f_options.f_main.f_specific.f_log_date_format -row 3 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_log_date_format.l_format -row 0 -column 0 -sticky new
   grid .f_options.f_main.f_specific.f_log_date_format.e_format -row 0 -column 1 -sticky new
   grid .f_options.f_main.f_specific.f_log_date_format.b_format -row 0 -column 2 -sticky new
   grid rowconfigure .f_options.f_main.f_specific 3 -weight 1
   grid rowconfigure .f_options.f_main.f_specific.f_log_date_format 1 -weight 1
   grid columnconfigure .f_options.f_main.f_specific.f_log_date_format 1 -weight 1
   
   set log_date_state ${temp_config(LOGDATE)}

   if { $temp_config(LOGDATE) == 0 } {
     .f_options.f_main.f_specific.f_log_date_format.e_format configure -state disabled
     .f_options.f_main.f_specific.f_log_date_format.b_format configure -state disabled
   } else {
     .f_options.f_main.f_specific.f_log_date_format.e_format configure -state normal
     .f_options.f_main.f_specific.f_log_date_format.b_format configure -state normal
   }

   set log_date_state ${temp_config(LOGDATE)}

   set_min_size_to_natural_size .f_options
}

proc log_date_toggle {} {
    global log_date_state temp_config
    if { $log_date_state != 0 } {
     .f_options.f_main.f_specific.f_log_date_format.e_format configure -state disabled
     .f_options.f_main.f_specific.f_log_date_format.b_format configure -state disabled
     set temp_config(LOGDATE) 0
    } else {
     .f_options.f_main.f_specific.f_log_date_format.e_format configure -state normal
     .f_options.f_main.f_specific.f_log_date_format.b_format configure -state normal
     set temp_config(LOGDATE) 1
    }
}

proc advanced_options {} {
   global cur_font_size
   global temp_config
   global last_open_error

   wm title .f_options "Advanced options"

   frame .f_options.f_main.f_specific.frame
   label .f_options.f_main.f_specific.label \
       -text "Advanced options" \
       -font "helvetica $cur_font_size bold"
    
   grid .f_options.f_main.f_specific.label -in .f_options.f_main.f_specific.frame -row 0 -column 0
   grid .f_options.f_main.f_specific.frame -in .f_options.f_main.f_specific -row 0 -column 0

   set_min_size_to_natural_size .f_options
}

proc apply_cfg {} {
    global config temp_config SRLFILE last_open_error CURHIDDEN
    .txtfrm.txt configure -insertbackground "${temp_config(FOREGROUND)}" \
                           -bg "${temp_config(BACKGROUND)}" \
                           -fg "${temp_config(FOREGROUND)}" \
                           -selectforeground "${temp_config(BACKGROUND)}" \
                           -selectbackground "${temp_config(FOREGROUND)}" \
                           -font "${temp_config(TEXTFONT)} ${temp_config(TEXTSIZE)}" 
    .cmdent configure -insertbackground "${temp_config(FOREGROUND)}" \
                           -bg "${temp_config(BACKGROUND)}" \
                           -fg "${temp_config(FOREGROUND)}" \
                           -selectforeground "${temp_config(BACKGROUND)}" \
                           -selectbackground "${temp_config(FOREGROUND)}" \
                           -font "${temp_config(TEXTFONT)} ${temp_config(TEXTSIZE)}" 
    if { $temp_config(WRAP) && ! $config(WRAP) } {
        .txtfrm.txt configure -xscrollcommand ""
    destroy .txtfrm.srl_x
        grid .txtbtmlbl -in .txtfrm -row 1 -column 1
        grid .cmdent -in .txtfrm -row 1 -column 0 -columnspan 1 -sticky ew
    } elseif { ! $temp_config(WRAP) && $config(WRAP) } {
        .txtfrm.txt configure -xscrollcommand ".txtfrm.srl_x set"
        scrollbar .txtfrm.srl_x -orient h -command ".txtfrm.txt xview"
        grid .txtfrm.srl_x -row 1 -column 0 -sticky ew 
        grid .txtbtmlbl -in .txtfrm -row 1 -column 1
        grid .cmdent -in .txtfrm -row 2 -column 0 -columnspan 2 -sticky ew
    update
    }
    if { $temp_config(COMMANDFILE) != $config(COMMANDFILE) } {
        readcmdfile $temp_config(COMMANDFILE)
    }

    if { ($temp_config(NUMCOMMANDS) != $config(NUMCOMMANDS) || \
          $temp_config(COMMANDFILE) != $config(COMMANDFILE)) && \
     ! $CURHIDDEN } {
            set_num_commands $temp_config(NUMCOMMANDS)
    }

    if { ! $CURHIDDEN } {
        for {set i 0} {$i < $temp_config(NUMCOMMANDS)} {incr i} {
            .cmdfrm.ent$i configure -insertbackground "${temp_config(FOREGROUND)}" \
                                    -bg "${temp_config(BACKGROUND)}" \
                                    -fg "${temp_config(FOREGROUND)}" \
                                    -selectforeground "${temp_config(BACKGROUND)}" \
                                    -selectbackground "${temp_config(FOREGROUND)}" \
                                    -font "${temp_config(TEXTFONT)} ${temp_config(TEXTSIZE)}" \
                                    -textvariable Cmd::entryText($i)
            .cmdfrm.rb$i configure -font "helvetica ${temp_config(TEXTSIZE)}"
        }
    }
    if { $temp_config(DEVICE) != $config(DEVICE) || \
     $temp_config(BAUD) != $config(BAUD) || \
     $temp_config(PARITY) != $config(PARITY) || \
     $temp_config(STOP) != $config(STOP) || \
     $temp_config(DATA) != $config(DATA) || \
         $last_open_error == 1 } {
         catch { close $SRLFILE } results
         set last_open_error [open_connection temp_config]
    }

    if { $temp_config(AUTOCOMPLETEFILE) != "none" && \
     $temp_config(AUTOCOMPLETEFILE) != $config(AUTOCOMPLETEFILE) && \
     ! [catch {open $temp_config(AUTOCOMPLETEFILE) r} acFileId] } {
        gets $acFileId line
        catch [array set Hist::autoCompleteList $line]
        close $acFileId
    }

    array set config [array get temp_config]
    new_scroll
}

proc load_cfg {} {
    global temp_config
    set filename [tk_getOpenFile -title "Choose configuration file"]
    if { $filename != "" } {
        readConfig temp_config "$filename"
        set_specific_option 1
    }
}

proc get_options {} {
    global temp_config
    global config
    global cur_font_size
    global curoption
    global CONFIGFILENAME
    global D_CONFIGFILENAME

    array set temp_config [ array get config ]
    set cur_font_size ${temp_config(TEXTSIZE)}

    toplevel .f_options
 
    #set up frames
    frame .f_options.f_main
    frame .f_options.f_main.f_chooser
    frame .f_options.f_main.f_specific
    frame .f_options.f_main.f_buttons
    grid .f_options.f_main -row 0 -column 0 -sticky nsew
    grid .f_options.f_main.f_chooser -row 0 -column 0 -sticky nsew
    grid .f_options.f_main.f_specific -row 0 -column 1 -sticky nsew
    grid .f_options.f_main.f_buttons -row 1 -column 0 -sticky sew
    grid .f_options.f_main.f_buttons -columnspan 2
    grid columnconfigure .f_options 0 -weight 1
    grid rowconfigure .f_options 0 -weight 1
    grid columnconfigure .f_options.f_main 1 -weight 1
    grid rowconfigure .f_options.f_main 0 -weight 1
    grid rowconfigure .f_options.f_main.f_chooser 0 -weight 1
    grid columnconfigure .f_options.f_main.f_chooser 0 -weight 1

    #set up option chooser
    listbox .f_options.f_main.f_chooser.lb_chooser -listvariable option_list \
       -font "helvetica $cur_font_size bold" -selectmode single
    grid .f_options.f_main.f_chooser.lb_chooser -row 0 -column 0 -sticky nsew

    .f_options.f_main.f_chooser.lb_chooser delete 0 end
    .f_options.f_main.f_chooser.lb_chooser insert 0 \
        "Window" "Commands" "Connection" "Logging" 
#"Advanced"

    #set up buttons
    button .f_options.f_main.f_buttons.b_save -text "Save As Default" -command {saveConfig $D_CONFIGFILENAME} -font "helvetica $cur_font_size"
    button .f_options.f_main.f_buttons.b_save_as -text "Save As" -command {saveConfigToFile} -font "helvetica $cur_font_size"
    button .f_options.f_main.f_buttons.b_load -text "Load" -command "load_cfg" -font "helvetica $cur_font_size"
    button .f_options.f_main.f_buttons.b_apply -text "Apply" -command {apply_cfg} -font "helvetica $cur_font_size"
    button .f_options.f_main.f_buttons.b_ok -text "OK" -command {apply_cfg; if { $last_open_error == 0 } { grab release .f_options; destroy .f_options} } -font "helvetica $cur_font_size"
    button .f_options.f_main.f_buttons.b_cancel -text "Cancel" -command {\
        if { $last_open_error == 0 } {\
                grab release .f_options; destroy .f_options\
            } else { \
        tk_messageBox -icon error -type ok \
           -message "Must have a valid connection" \
            }\
        } -font "helvetica $cur_font_size"
    grid .f_options.f_main.f_buttons.b_save -row 0 -column 0
    grid .f_options.f_main.f_buttons.b_save_as -row 0 -column 1
    grid .f_options.f_main.f_buttons.b_load -row 0 -column 2
    grid .f_options.f_main.f_buttons.b_apply -row 0 -column 3
    grid .f_options.f_main.f_buttons.b_ok -row 0 -column 4
    grid .f_options.f_main.f_buttons.b_cancel -row 0 -column 5

    grid columnconfigure .f_options.f_main.f_buttons {0 1 2 3 4 5} -weight 1

    bind .f_options.f_main.f_chooser.lb_chooser <<ListboxSelect>> [list set_specific_option 0]

    set curoption 0
    window_options

    .f_options.f_main.f_chooser.lb_chooser selection set 0
    grab .f_options
    wm transient .f_options .
}


proc Scripter {} {
    if { [catch {toplevel .f_Scripter}] } {
        raise .f_Scripter
	return
    }

    set base .f_Scripter
    set root $base
    
    frame $base.frmScriptCommandsButtons

    frame $base.frmScriptButtons \
        -borderwidth 2 \
        -relief ridge

    frame $base.frmScriptRepeat 

    frame $base.frmScriptStatusRun 

    frame $base.frmScriptStatus \
        -borderwidth 4 \
        -relief sunken

    frame $base.frmScriptRunNumber \
        -borderwidth 4 \
        -relief sunken
    
    frame $base.frm_ActionButtons

    frame $base.frm_ScriptRunType \
        -borderwidth 2 \
        -relief sunken

    label $base.lblScriptPrompt \
        -text Prompt:

    entry $base.ent_ScriptPrompt \
        -cursor {} \
        -textvariable Script::prompt

    label $base.lblScriptActions \
        -text Actions:

    listbox $base.lbRunningActions \
        -height 10 \
        -width 0 \
        -yscrollcommand ".f_Scripter.scrlActionsY set" \
        -listvariable Script::actionStateList

    bind .f_Scripter.lbRunningActions <1> break

    listbox $base.lbActions \
        -height 10 \
        -width 60 \
        -xscrollcommand ".f_Scripter.scrlActionsX set" \
        -yscrollcommand ".f_Scripter.scrlActionsY set" \
    -selectmode extended \
    -listvariable Script::actionNameList

    scrollbar $base.scrlActionsY \
        -command ScriptActionsFixScrollbars
    

    scrollbar $base.scrlActionsX \
        -command ".f_Scripter.lbActions xview" \
        -orient horizontal

    button $base.btnScriptActionsMoveUp \
        -command ScriptActionsMoveUp \
        -text {Move Up}

    button $base.btnScriptActionsMoveDown \
        -command ScriptActionsMoveDown \
        -text {Move Down}

    button $base.btnScriptActionsAddNewAbove \
        -command ScriptActionsAddNewAbove \
        -text {Add New Above}

    button $base.btnScriptActionsAddNewBelow \
        -command ScriptActionsAddNewBelow \
        -text {Add New Below}

    button $base.btnScriptActionsModify \
        -command ScriptActionsModify \
        -text Modify

    button $base.btnScriptActionsCut \
        -command ScriptActionsCut \
        -text Cut

    button $base.btnScriptActionsCopy \
        -command ScriptActionsCopy \
        -text Copy

    button $base.btnScriptActionsPasteAbove \
        -command ScriptActionsPasteAbove \
        -text {Paste Above}

    button $base.btnScriptActionsPasteBelow \
        -command ScriptActionsPasteBelow \
        -text {Paste Below}

    button $base.btnScriptActionsDelete \
        -command ScriptActionsDelete \
        -text Delete

    label $base.lblScript \
        -text Script:

    label $base.lblScriptRepeat \
        -text "Number of runs:"

    entry $base.entScriptRepeat -width 8 \
        -textvariable Script::numberOfRepeats \
        -validate all -vcmd "ScriptRepeatValidate %P"

    button $base.btnScriptSave \
        -command ScriptSave \
        -text Save

    button $base.btnScriptSaveAs \
        -command ScriptSaveAs \
        -text {Save As}

    button $base.btnScriptLoad \
        -command ScriptLoad \
        -text Load

    button $base.btnScriptClose \
        -command ScriptClose \
        -text Close

    button $base.btnScriptRunStop \
        -command ScriptRunStop \
        -text "Run"

    radiobutton $base.cbtScriptRunAll \
        -borderwidth 0 \
        -selectcolor green \
        -text {Run All} \
        -value 0 \
    -command ScriptUpdateRunType \
        -variable Script::runType

    radiobutton $base.cbtScriptRunSelected \
        -borderwidth 0 \
        -selectcolor green \
        -text {Run Selected} \
        -value 1 \
    -command ScriptUpdateRunType \
        -variable Script::runType

    radiobutton $base.cbtScriptRunFromSelected \
        -borderwidth 0 \
        -pady 0 \
        -selectcolor green \
        -text {Run From First Selected} \
        -value 2 \
    -command ScriptUpdateRunType \
        -variable Script::runType

    radiobutton $base.cbtScriptRunToSelected \
        -borderwidth 0 \
        -pady 0 \
        -selectcolor green \
        -text {Run To Last Selected} \
        -value 3 \
    -command ScriptUpdateRunType \
        -variable Script::runType

    label $base.lblScriptStatus \
        -borderwidth 0 \
        -pady 0 \
        -text Status:

    label $base.lblScriptRunNumber \
        -borderwidth 0 \
        -pady 0 \
    -textvariable Script::runNumber

    label $base.lblScriptStatusImp \
        -borderwidth 0 \
        -pady 0 \
    -textvariable Script::status


    # Add contents to menus

    # Geometry management

    grid $base.frmScriptCommandsButtons -in $root    -row 4 -column 2  \
        -columnspan 3
    grid $base.frmScriptRepeat -in $root    -row 7 -column 2  \
        -columnspan 3 \
        -sticky w
    grid $base.frmScriptButtons -in $root    -row 8 -column 2  \
        -columnspan 3 \
        -sticky w
    grid $base.frmScriptStatusRun -in $root    -row 10 -column 1  \
        -columnspan 4 \
        -sticky ew
    grid $base.frmScriptStatus -in $root.frmScriptStatusRun -row 1 -column 1  \
        -sticky ew
    grid $base.frmScriptRunNumber -in $root.frmScriptStatusRun -row 1 -column 2  \
        -sticky w
    grid $base.frm_ActionButtons -in $root    -row 5 -column 2  \
        -columnspan 3
    grid $base.frm_ScriptRunType -in $base.frmScriptButtons    -row 1 -column 6  \
        -sticky w
    grid $base.lblScriptPrompt -in $root    -row 1 -column 1  \
        -sticky w
    grid $base.ent_ScriptPrompt -in $root    -row 1 -column 2  \
        -columnspan 3 \
        -sticky ew
    grid $base.lblScriptActions -in $root    -row 2 -column 1  \
        -sticky nw
    grid $base.lbRunningActions -in $root    -row 2 -column 2  \
        -sticky nesw
    grid $base.lbActions -in $root    -row 2 -column 3  \
        -sticky nesw
    grid $base.scrlActionsY -in $root    -row 2 -column 4  \
        -sticky ns
    grid $base.scrlActionsX -in $root    -row 3 -column 3  \
        -sticky ew
    grid $base.btnScriptActionsMoveUp -in $base.frmScriptCommandsButtons    -row 1 -column 1 
    grid $base.btnScriptActionsMoveDown -in $base.frmScriptCommandsButtons    -row 1 -column 2 
    grid $base.btnScriptActionsAddNewAbove -in $base.frmScriptCommandsButtons    -row 1 -column 3 
    grid $base.btnScriptActionsAddNewBelow -in $base.frmScriptCommandsButtons    -row 1 -column 4 
    grid $base.btnScriptActionsModify -in $base.frm_ActionButtons    -row 1 -column 1 
    grid $base.btnScriptActionsCut -in $base.frm_ActionButtons    -row 1 -column 2 
    grid $base.btnScriptActionsCopy -in $base.frm_ActionButtons    -row 1 -column 3 
    grid $base.btnScriptActionsPasteAbove -in $base.frm_ActionButtons    -row 1 -column 4 
    grid $base.btnScriptActionsPasteBelow -in $base.frm_ActionButtons    -row 1 -column 5 
    grid $base.btnScriptActionsDelete -in $base.frm_ActionButtons    -row 1 -column 6 
    grid $base.lblScript -in $root    -row 7 -column 1  \
        -sticky nw
    grid $base.lblScriptRepeat -in $base.frmScriptRepeat    -row 1 -column 1  \
        -sticky nw
    grid $base.entScriptRepeat -in $base.frmScriptRepeat    -row 1 -column 2  \
        -sticky nw
    grid $base.btnScriptSave -in $base.frmScriptButtons    -row 1 -column 1  \
        -sticky w
    grid $base.btnScriptSaveAs -in $base.frmScriptButtons    -row 1 -column 2  \
        -sticky w
    grid $base.btnScriptLoad -in $base.frmScriptButtons    -row 1 -column 3  \
        -sticky w
    grid $base.btnScriptClose -in $base.frmScriptButtons    -row 1 -column 4  \
        -sticky w
    grid $base.btnScriptRunStop -in $base.frm_ScriptRunType    -row 1 -column 1  \
        -rowspan 4
    grid $base.cbtScriptRunAll -in $base.frm_ScriptRunType    -row 1 -column 2  \
        -sticky w
    grid $base.cbtScriptRunSelected -in $base.frm_ScriptRunType    -row 2 -column 2  \
        -sticky w
    grid $base.cbtScriptRunFromSelected -in $base.frm_ScriptRunType    -row 3 -column 2  \
        -sticky w
    grid $base.cbtScriptRunToSelected -in $base.frm_ScriptRunType    -row 4 -column 2  \
        -sticky w
    grid $base.lblScriptStatus -in $base.frmScriptStatus    -row 1 -column 1  \
        -sticky w
    grid $base.lblScriptStatusImp -in $base.frmScriptStatus    -row 1 -column 2  \
        -sticky w
    grid $base.lblScriptRunNumber -in $base.frmScriptRunNumber    -row 1 -column 1  \
        -sticky e

    # Resize behavior management

    grid rowconfigure $base.frmScriptButtons 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmScriptButtons 1 -weight 0 -minsize 23 -pad 0
    grid columnconfigure $base.frmScriptButtons 2 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmScriptButtons 3 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmScriptButtons 4 -weight 0 -minsize 17 -pad 0
    grid columnconfigure $base.frmScriptButtons 5 -weight 0 -minsize 17 -pad 0
    grid columnconfigure $base.frmScriptButtons 6 -weight 0 -minsize 30 -pad 0

    grid rowconfigure $base.frmScriptStatusRun 1 -weight 0 -minsize 15 -pad 0
    grid columnconfigure $base.frmScriptStatusRun 1 -weight 1 -minsize 2 -pad 0
    grid columnconfigure $base.frmScriptStatusRun 2 -weight 0 -minsize 2 -pad 0
    grid rowconfigure $base.frmScriptStatus 1 -weight 0 -minsize 15 -pad 0
    grid columnconfigure $base.frmScriptStatus 1 -weight 0 -minsize 2 -pad 0
    grid columnconfigure $base.frmScriptStatus 2 -weight 1 -minsize 394 -pad 0
    grid rowconfigure $base.frmScriptRunNumber 1 -weight 1 -minsize 15 -pad 0
    grid columnconfigure $base.frmScriptRunNumber 1 -weight 0 -minsize 3 -pad 0

    grid columnconfigure $base.frm_ScriptRunType 1 -weight 0 -minsize 50 -pad 0

    grid rowconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid rowconfigure $root 2 -weight 1 -minsize 120 -pad 0
    grid rowconfigure $root 3 -weight 0 -minsize 11 -pad 0
    grid rowconfigure $root 4 -weight 0 -minsize 5 -pad 0
    grid rowconfigure $root 5 -weight 0 -minsize 15 -pad 0
    grid rowconfigure $root 6 -weight 0 -minsize 18 -pad 0
    grid rowconfigure $root 7 -weight 0 -minsize 30 -pad 0
    grid rowconfigure $root 8 -weight 0 -minsize 18 -pad 0
    grid rowconfigure $root 9 -weight 0 -minsize 15 -pad 0
    grid columnconfigure $root 1 -weight 0 -minsize 2 -pad 0
    grid columnconfigure $root 2 -weight 0 -minsize 16 -pad 0
    grid columnconfigure $root 3 -weight 1 -minsize 400 -pad 0
    grid columnconfigure $root 4 -weight 0 -minsize 2 -pad 0

    grid rowconfigure $base.frmScriptCommandsButtons 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmScriptCommandsButtons 1 -weight 0 -minsize 24 -pad 0
    grid columnconfigure $base.frmScriptCommandsButtons 2 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmScriptCommandsButtons 3 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmScriptCommandsButtons 4 -weight 0 -minsize 30 -pad 0

    grid rowconfigure $base.frm_ActionButtons 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frm_ActionButtons 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frm_ActionButtons 2 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frm_ActionButtons 3 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frm_ActionButtons 4 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frm_ActionButtons 5 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frm_ActionButtons 6 -weight 0 -minsize 30 -pad 0

    update
    wm minsize $base [winfo reqwidth $base] [winfo reqheight $base]
    raise $base
    wm title $base "ScriptRunner"
    #grab $base
    #wm transient $base
# additional interface code

   bind .f_Scripter.lbActions <<ListboxSelect>> ScriptActionUpdateSelectStates
   bind .f_Scripter.lbActions <Double-1> ScriptActionsModify
   ScriptActionUpdateSelectStates
   # end additional interface code
}

proc ScriptSave {} {
    if { $Script::filename == "" } {
        ScriptSaveAs
    } else {
        if {[catch {open $Script::filename w} scriptFileId] } {
            tk_messageBox -type ok -icon error \
            -message "Could not open script file: $scriptFileId"
        } else {
        puts $scriptFileId $Script::prompt
        puts $scriptFileId $Script::actionList
        close $scriptFileId
        }
	raise .f_Scripter
    }
}

proc ScriptSaveAs {} {
    set filename [tk_getSaveFile -title "Script file name" -initialfile $Script::filename]
    if {$filename != ""} {
        set Script::filename $filename
        ScriptSave
    } else {
        raise .f_Scripter
    }
}

proc ScriptLoad {} {
    set filename [tk_getOpenFile -title "Script file name" -initialfile $Script::filename]
    ScriptActionBlank
    if {$filename != ""} {
        set Script::filename $filename
        if {[catch {open $Script::filename r} scriptFileId] } {
            tk_messageBox -type ok -icon error \
            -message "Could not open script file: $scriptFileId"
        } else {
        if { [catch {
            set Script::actionStateList {}
            set Script::actionList {}
            set Script::actionNameList {}
            set Script::numberOfRepeats 1
            gets $scriptFileId Script::prompt
            while { ![eof $scriptFileId] } {
                gets $scriptFileId tempActionList
                append Script::actionList "\n" $tempActionList
            }

            foreach actionString $Script::actionList {
                lappend Script::actionStateList " "
            array set action $actionString
            lappend Script::actionNameList $action(NAME)
        }
        } errorId] } {
                tk_messageBox -type ok -icon error \
                -message "Error reading script file: $errorId"
        }
           close $scriptFileId
        ScriptActionUpdateSelectStates
        }
    }
    raise .f_Scripter
}

proc ScriptClose {} {
    KillAllChildren .f_Scripter
    grab release .f_Scripter
    destroy .f_Scripter
}

proc ScriptRunStop {} {
    global runNumber
    if { $Script::running } {
        set Script::running 0
        $Script::curAction(STOP_FUNC)
        ScriptPrepScripterGuiForStop
    } else {
        if { $Script::numberOfRepeats == "" } {
            show_message "Must specify number of script runs."
            return
	}
        wm maxsize .f_Scripter [winfo width .f_Scripter] [winfo vrootheight .]
        wm minsize .f_Scripter [winfo width .f_Scripter] [winfo reqheight .f_Scripter]
        set Script::running 1
        set nonActiveBg [.f_Scripter.lbRunningActions itemcget 0 -background]
        ScriptPrepScripterGuiForRun
        set lastIndex -1
        set totalRuns $Script::numberOfRepeats
        for {set runNumber 1} {$runNumber <= $totalRuns && $Script::running} {incr runNumber} {
            set Script::runNumber "${runNumber}/${totalRuns}"
            for {set index 0} {$index < [llength $Script::actionStateList] && $Script::running} {incr index} {
                if { $lastIndex != -1 } {
                    set Script::actionStateList [lreplace $Script::actionStateList $lastIndex $lastIndex "X"]
                    .f_Scripter.lbRunningActions itemconfigure $lastIndex -background $nonActiveBg
                }
                if { [lindex $Script::actionStateList $index] == "X" } {
                    .f_Scripter.lbActions see $index
                    .f_Scripter.lbRunningActions see $index
                    .f_Scripter.lbRunningActions itemconfigure $index -background green
                    set Script::actionResult pending
                    array set Script::curAction [lindex $Script::actionList $index]
                    array set Script::curActionParams $Script::curAction(PARAMS)
                    if { $lastIndex != -1 } {
                        set Script::actionStateList [lreplace $Script::actionStateList $lastIndex $lastIndex "X"]
                        .f_Scripter.lbRunningActions itemconfigure $lastIndex -background $nonActiveBg
                    }
                    set Script::actionStateList [lreplace $Script::actionStateList $index $index ">"]
                    set lastIndex $index
                    set Script::status "Running action \"$Script::curAction(NAME)\""
                    $Script::curAction(RUN_FUNC)
                }
            }
        }
        incr runNumber -1
        if { $lastIndex != -1 } {
            set Script::actionStateList [lreplace $Script::actionStateList $lastIndex $lastIndex "X"]
            .f_Scripter.lbRunningActions itemconfigure $lastIndex -background $nonActiveBg
        }

        set Script::runNumber "0/0"
        if { $Script::actionResult == "timeout" } {
            set Script::status "Last run stopped prematurely due to wait timeout after $runNumber runs"
        } elseif { $Script::actionResult == "aborted" } {
            set Script::status "Last run stopped by user after $runNumber runs"
        }

        if { $Script::running } {
            set Script::status "Last run completed successfully after $runNumber runs"
            show_message "Script complete!" .f_Scripter
            ScriptPrepScripterGuiForStop
            set Script::running 0
        } else {
            ScriptPrepScripterGuiForStop
	}
        wm maxsize .f_Scripter [winfo vrootwidth .] [winfo vrootheight .]
        wm minsize .f_Scripter [winfo reqwidth .f_Scripter] [winfo reqheight .f_Scripter]
    }
}

proc ScriptPrepScripterGuiForRun {} {
    .f_Scripter.ent_ScriptPrompt configure -state disabled
    bind .f_Scripter.lbActions <1> break
    bind .f_Scripter.lbActions <Double-1> break
    bind .f_Scripter.lbActions <<ListboxSelect>> break
    .f_Scripter.btnScriptActionsMoveUp configure -state disabled
    .f_Scripter.btnScriptActionsMoveDown configure -state disabled
    .f_Scripter.btnScriptActionsAddNewAbove configure -state disabled
    .f_Scripter.btnScriptActionsAddNewBelow configure -state disabled
    .f_Scripter.btnScriptActionsModify configure -state disabled
    .f_Scripter.btnScriptActionsCut configure -state disabled
    .f_Scripter.btnScriptActionsCopy configure -state disabled
    .f_Scripter.btnScriptActionsPasteAbove configure -state disabled
    .f_Scripter.btnScriptActionsPasteBelow configure -state disabled
    .f_Scripter.btnScriptActionsDelete configure -state disabled
    .f_Scripter.entScriptRepeat configure -state disabled
    .f_Scripter.btnScriptSave configure -state disabled
    .f_Scripter.btnScriptSaveAs configure -state disabled
    .f_Scripter.btnScriptLoad configure -state disabled
    .f_Scripter.btnScriptClose configure -state disabled
    .f_Scripter.cbtScriptRunAll configure -state disabled
    .f_Scripter.cbtScriptRunSelected configure -state disabled
    .f_Scripter.cbtScriptRunFromSelected configure -state disabled
    .f_Scripter.cbtScriptRunToSelected configure -state disabled
    .f_Scripter.btnScriptRunStop configure -text "Stop"
}

proc ScriptPrepScripterGuiForStop {} {
    .f_Scripter.ent_ScriptPrompt configure -state normal
    bind .f_Scripter.lbActions <1> ""
    bind .f_Scripter.lbActions <Double-1> ScriptActionsModify
    bind .f_Scripter.lbActions <<ListboxSelect>> ScriptActionUpdateSelectStates
    .f_Scripter.btnScriptActionsAddNewAbove configure -state normal
    .f_Scripter.btnScriptActionsAddNewBelow configure -state normal
    .f_Scripter.entScriptRepeat configure -state normal
    .f_Scripter.btnScriptSave configure -state normal
    .f_Scripter.btnScriptSaveAs configure -state normal
    .f_Scripter.btnScriptLoad configure -state normal
    .f_Scripter.btnScriptClose configure -state normal
    .f_Scripter.cbtScriptRunAll configure -state normal
    .f_Scripter.cbtScriptRunSelected configure -state normal
    .f_Scripter.cbtScriptRunFromSelected configure -state normal
    .f_Scripter.cbtScriptRunToSelected configure -state normal
    .f_Scripter.btnScriptRunStop configure -text "Run"
    ScriptSetActionButtonStates
}

proc ScriptRepeatValidate { val } {
    if { [string is integer $val] } {
        if { $val == "" } {
            return 1
	}
	if { $val > 0 } {
	    return 1
	}
	return 0
    } else {
        return 0
    }
}

proc ScriptActionsFixScrollbars args {
    if { [llength $args] == 2 } {
        .f_Scripter.lbRunningActions yview [lindex $args 0] [lindex $args 1]
        .f_Scripter.lbActions yview [lindex $args 0] [lindex $args 1]
    } else {
        .f_Scripter.lbRunningActions yview [lindex $args 0] [lindex $args 1] [lindex $args 2]
        .f_Scripter.lbActions yview [lindex $args 0] [lindex $args 1] [lindex $args 2]
    }
}


proc ScriptActionUpdateSelectStates {} {
   ScriptUpdateRunType
   ScriptSetActionButtonStates
}

proc ScriptSetActionButtonStates {} {
    set selectedActions [.f_Scripter.lbActions curselection]
    if { [llength $selectedActions] > 0 } {
    if { [lindex $selectedActions 0] == 0 } {
            .f_Scripter.btnScriptActionsMoveUp configure -state disabled
        } else {
            .f_Scripter.btnScriptActionsMoveUp configure -state normal
    }
    if { [lindex $selectedActions end] == \
         [expr [llength $Script::actionList] - 1] } {
            .f_Scripter.btnScriptActionsMoveDown configure -state disabled
    } else {
            .f_Scripter.btnScriptActionsMoveDown configure -state normal
        }
        if { [llength $selectedActions] == 1 } {
            .f_Scripter.btnScriptActionsModify configure -state normal
    } else {
            .f_Scripter.btnScriptActionsModify configure -state disabled
    }
        .f_Scripter.btnScriptActionsCut configure -state normal
        .f_Scripter.btnScriptActionsCopy configure -state normal
        .f_Scripter.btnScriptActionsDelete configure -state normal
    } else {
        .f_Scripter.btnScriptActionsMoveUp configure -state disabled
        .f_Scripter.btnScriptActionsMoveDown configure -state disabled
        .f_Scripter.btnScriptActionsModify configure -state disabled
        .f_Scripter.btnScriptActionsCut configure -state disabled
        .f_Scripter.btnScriptActionsCopy configure -state disabled
        .f_Scripter.btnScriptActionsDelete configure -state disabled
    }
    if { [llength $Script::actionClipboard] > 0 } {
        .f_Scripter.btnScriptActionsPasteBelow configure -state normal
        .f_Scripter.btnScriptActionsPasteAbove configure -state normal
    } else {
        .f_Scripter.btnScriptActionsPasteBelow configure -state disabled
        .f_Scripter.btnScriptActionsPasteAbove configure -state disabled
    }
}

proc ScriptSetRunTypeAll {} {
    for {set index 0} {$index < [llength $Script::actionStateList]} {incr index} {
        set Script::actionStateList [lreplace $Script::actionStateList $index $index "X"]
    }
}

proc ScriptSetRunTypeSelected {} {
    for {set index 0} {$index < [llength $Script::actionStateList]} {incr index} {
    if { [lsearch [.f_Scripter.lbActions curselection] $index] == -1 } {
            set Script::actionStateList [lreplace $Script::actionStateList $index $index " "]
        } else {
            set Script::actionStateList [lreplace $Script::actionStateList $index $index "X"]
    }
    }
}

proc ScriptSetRunTypeFromSelected {} {
    if { [llength [.f_Scripter.lbActions curselection]] == 0} {
        set firstSelected [llength $Script::actionStateList]
    } else {
        set firstSelected [lindex [.f_Scripter.lbActions curselection] 0]
    }
    for {set index 0} {$index < [llength $Script::actionStateList]} {incr index} {
    if { $index < $firstSelected } {
            set Script::actionStateList [lreplace $Script::actionStateList $index $index " "]
        } else {
            set Script::actionStateList [lreplace $Script::actionStateList $index $index "X"]
    }
    }
}

proc ScriptSetRunTypeToSelected {} {
    if { [llength [.f_Scripter.lbActions curselection]] == 0} {
        set lastSelected -1
    } else {
        set lastSelected [lindex [.f_Scripter.lbActions curselection] end]
    }
    for {set index 0} {$index < [llength $Script::actionStateList]} {incr index} {
    if { $index > $lastSelected } {
            set Script::actionStateList [lreplace $Script::actionStateList $index $index " "]
        } else {
            set Script::actionStateList [lreplace $Script::actionStateList $index $index "X"]
    }
    }
}

proc ScriptUpdateRunType {} {
    if { $Script::runType == 0 } {
        ScriptSetRunTypeAll
    } elseif { $Script::runType == 1 } {
        ScriptSetRunTypeSelected
    } elseif { $Script::runType == 2 } {
        ScriptSetRunTypeFromSelected
    } else {
        ScriptSetRunTypeToSelected
    }

    if { [lsearch $Script::actionStateList "X"] == -1 } {
        .f_Scripter.btnScriptRunStop configure -state disabled
    } else {
        .f_Scripter.btnScriptRunStop configure -state normal
    }
}

# ********************** Delete Actions Above ************************* 
proc ScriptActionsDelete {} {
    set Script::selectedActionIndexList [lsort -integer -decreasing [.f_Scripter.lbActions curselection]]

    foreach index $Script::selectedActionIndexList {
        set Script::actionList [lreplace $Script::actionList $index $index]
        set Script::actionStateList [lreplace $Script::actionStateList $index $index]
        set Script::actionNameList [lreplace $Script::actionNameList $index $index]
    }
    for {set index 0} {$index < [llength $Script::actionList]} {incr index} {
        .f_Scripter.lbActions selection clear $index
    }
    ScriptActionUpdateSelectStates
}

# ********************** Move Actions Up ************************* 
proc ScriptActionsMoveUp {} {
    # Go through each in the selected list and swap each with the one above
    foreach index [.f_Scripter.lbActions curselection] {
        set prev [expr $index - 1]
    set selAction [lindex $Script::actionList $index]
    set selActionName [lindex $Script::actionNameList $index]
    set selActionState [lindex $Script::actionStateList $index]
    set prevAction [lindex $Script::actionList $prev]
    set prevActionName [lindex $Script::actionNameList $prev]
    set prevActionState [lindex $Script::actionStateList $prev]
        set Script::actionList [lreplace $Script::actionList $prev $index \
                            $selAction $prevAction ]
        set Script::actionNameList [lreplace $Script::actionNameList $prev $index \
                            $selActionName $prevActionName ]
        set Script::actionStateList [lreplace $Script::actionStateList $prev $index \
                            $selActionState $prevActionState ]
    .f_Scripter.lbActions selection set $prev
    .f_Scripter.lbActions selection clear $index
    }
    ScriptActionUpdateSelectStates
}

# ********************** Move Actions Down ************************* 
proc ScriptActionsMoveDown {} {
    # Go through each in the selected list and swap each with the one above
    foreach index [lsort -decreasing -integer [.f_Scripter.lbActions curselection]] {
        set next [expr $index + 1]
    set selAction [lindex $Script::actionList $index]
    set selActionName [lindex $Script::actionNameList $index]
    set selActionState [lindex $Script::actionStateList $index]
    set nextAction [lindex $Script::actionList $next]
    set nextActionName [lindex $Script::actionNameList $next]
    set nextActionState [lindex $Script::actionStateList $next]
        set Script::actionList [lreplace $Script::actionList $index $next \
                            $nextAction $selAction ]
        set Script::actionNameList [lreplace $Script::actionNameList $index $next \
                            $nextActionName $selActionName ]
        set Script::actionStateList [lreplace $Script::actionStateList $index $next \
                            $nextActionState $selActionState ]
    .f_Scripter.lbActions selection set $next
    .f_Scripter.lbActions selection clear $index
    }
    ScriptActionUpdateSelectStates
}

# ********************** Copy Actions ************************* 
proc ScriptActionsCopy {} {
    set Script::actionClipboard {}
    foreach index [.f_Scripter.lbActions curselection] {
        lappend Script::actionClipboard [lindex $Script::actionList $index]
    }
    .f_Scripter.btnScriptActionsPasteBelow configure -state normal
    .f_Scripter.btnScriptActionsPasteAbove configure -state normal
}

# ********************** Cut Actions ************************* 
proc ScriptActionsCut {} {
    ScriptActionsCopy
    ScriptActionsDelete
}

# ********************** Paste Actions Below ************************* 
proc ScriptActionsPasteBelow {} {
    set Script::selectedActionIndexList [.f_Scripter.lbActions curselection]
    set clipBoardSize [llength $Script::actionClipboard]
    if {[llength $Script::selectedActionIndexList] != 0} {
        set index [expr [lindex $Script::selectedActionIndexList end] + 1]
    } else {
    set index end
    }  
    foreach action [list_reverse $Script::actionClipboard] {
    array set myaction $action
        set Script::actionStateList [linsert $Script::actionStateList $index " "]
        set Script::actionList [linsert $Script::actionList $index $action]
    set Script::actionNameList [linsert $Script::actionNameList $index $myaction(NAME)]
    }
    .f_Scripter.lbActions selection clear 0 end
    foreach index $Script::selectedActionIndexList {
        .f_Scripter.lbActions selection set $index
    }
    ScriptActionUpdateSelectStates
}

# ********************** Paste Actions Above ************************* 
proc ScriptActionsPasteAbove {} {
    set Script::selectedActionIndexList [.f_Scripter.lbActions curselection]
    set clipBoardSize [llength $Script::actionClipboard]
    if {[llength $Script::selectedActionIndexList] != 0} {
        set index [lindex $Script::selectedActionIndexList 0]
    } else {
    set index 0
    }  
    foreach action $Script::actionClipboard {
    array set myaction $action
        set Script::actionStateList [linsert $Script::actionStateList $index " "]
        set Script::actionList [linsert $Script::actionList $index $action]
    set Script::actionNameList [linsert $Script::actionNameList $index $myaction(NAME)]
    }

    .f_Scripter.lbActions selection clear 0 end
    foreach index $Script::selectedActionIndexList {
        .f_Scripter.lbActions selection set [expr $index + $clipBoardSize]
    }
    ScriptActionUpdateSelectStates
}

# ********************** Modify Action ************************* 
proc ScriptActionsModify {} {
    set Script::selectedActionIndexList [.f_Scripter.lbActions curselection]
    if { [llength $Script::selectedActionIndexList] == 1} {
        set Script::editActionCommitFunc "ScriptActionsModifyCommit"
        set index [lindex $Script::selectedActionIndexList 0]
        set actionString [lindex $Script::actionList $index]
        array set Script::curAction $actionString
        array set Script::curActionParams $Script::curAction(PARAMS)
    set Script::curActionType $Script::curAction(TYPE)
        ScriptActionsEditor
    }
}

proc ScriptActionsModifyCommit {} {
    if { [eval $Script::actionValidate] == 0 } {
        return 0
    }
    set Script::curAction(PARAMS) [array get Script::curActionParams]
    set index [lindex $Script::selectedActionIndexList 0]
    set Script::actionList [lreplace $Script::actionList $index $index [array get Script::curAction]]
    set Script::actionNameList [lreplace $Script::actionNameList $index $index $Script::curAction(NAME)]

    .f_Scripter.lbActions selection clear 0 end
    .f_Scripter.lbActions selection set [lindex $Script::selectedActionIndexList 0]

    ScriptActionUpdateSelectStates
    return 1
}

# ********************** Add Action Above ************************* 
proc ScriptActionsAddNewAbove {} {
    set Script::selectedActionIndexList [.f_Scripter.lbActions curselection]
    set Script::curAction(NAME) ""
    set Script::curActionType "Select Type"
    ScriptActionBlank 
    set Script::editActionCommitFunc "ScriptActionsAddNewAboveCommit"
    ScriptActionsEditor
}

proc ScriptActionsAddNewAboveCommit {} {
    if { [$Script::actionValidate] == 0 } {
        return 0
    }

    set Script::curAction(PARAMS) [array get Script::curActionParams]
    set index 0
    if {[llength $Script::selectedActionIndexList] > 0 } {
    set index [lindex $Script::selectedActionIndexList 0]
    }
    set Script::actionNameList [linsert $Script::actionNameList $index $Script::curAction(NAME)]
    set Script::actionList [linsert $Script::actionList $index [array get Script::curAction]]
    set Script::actionStateList [linsert $Script::actionStateList $index " "]

    .f_Scripter.lbActions selection clear 0 end
    foreach oldSelectedIndex $Script::selectedActionIndexList {
    if { $oldSelectedIndex >= $index } {
            .f_Scripter.lbActions selection set [expr $oldSelectedIndex + 1]
    }
    }

    ScriptActionUpdateSelectStates
    return 1
}

# ********************** Add New Action Below ************************* 
proc ScriptActionsAddNewBelow {} {
    set Script::selectedActionIndexList [.f_Scripter.lbActions curselection]
    set Script::curAction(NAME) ""
    set Script::curActionType "Select Type"
    ScriptActionBlank 
    set Script::editActionCommitFunc "ScriptActionsAddNewBelowCommit"
    ScriptActionsEditor
}

proc ScriptActionsAddNewBelowCommit {} {
    if { [$Script::actionValidate] == 0 } {
        return 0
    }

    set Script::curAction(PARAMS) [array get Script::curActionParams]
    set index end
    if {[llength $Script::selectedActionIndexList] > 0} {
    set index [expr [lindex $Script::selectedActionIndexList end] + 1]
    }
    set Script::actionNameList [linsert $Script::actionNameList $index $Script::curAction(NAME)]
    set Script::actionList [linsert $Script::actionList $index [array get Script::curAction]]
    set Script::actionStateList [linsert $Script::actionStateList $index " "]

    .f_Scripter.lbActions selection clear 0 end
    foreach index $Script::selectedActionIndexList {
        .f_Scripter.lbActions selection set $index
    }

    ScriptActionUpdateSelectStates
    return 1
}


proc ScriptActionsEditor {} {
    toplevel .frm_ScriptActionEditor
    set base .frm_ScriptActionEditor
    set root $base
    
    frame $base.frmActionParamHolder \
        -borderwidth 2 \
        -relief groove

    frame $base.frmActionButtons

    frame $base.frmActionParameters

    label $base.lblActionName \
        -text {Action Name:}

    button $base.btnActionOk \
        -command { 
        if { [$Script::editActionCommitFunc] != 0 } {
            KillAllChildren .frm_ScriptActionEditor
            grab release .frm_ScriptActionEditor
            destroy .frm_ScriptActionEditor
            raise .f_Scripter
                } } \
        -text OK -state disabled

    entry $base.entActionName \
        -textvariable Script::curAction(NAME) \
           -validate all \
           -vcmd "ScriptActionValidateName %P"

    label $base.lblActionType \
        -text {Action Type:}

    set cmd [list tk_optionMenu $base.tom_ActionTypeMenu Script::curActionType]
    foreach actionType $Script::actionTypesList {
        lappend cmd $actionType
    }

    set actionTypeMenu [eval $cmd]

    set tempActionTypesList [lreplace $Script::actionTypesList 0 0]
    set tempActionEditFuncList [lreplace $Script::actionEditFuncList 0 0]

    set index 0
    foreach actionEditFunc $Script::actionEditFuncList {
        $actionTypeMenu entryconfigure $index -command "$actionEditFunc $base.frmActionParameters"
    incr index
    }

    label $base.label#3 \
        -text {Action Parameters}

    button $base.btnActionCancel \
        -command ActionCancel \
        -text Cancel \
    -command { grab release .frm_ScriptActionEditor
               destroy .frm_ScriptActionEditor
               raise .f_Scripter }


    # Add contents to menus

    # Geometry management

    grid $base.frmActionParamHolder -in $root    -row 3 -column 1  \
        -columnspan 2 \
        -sticky nesw
    grid $base.frmActionButtons -in $root    -row 4 -column 1  \
        -columnspan 2
    grid $base.frmActionParameters -in $base.frmActionParamHolder    -row 2 -column 1  \
        -sticky nesw
    grid $base.lblActionName -in $root    -row 1 -column 1  \
        -sticky w
    grid $base.entActionName -in $root    -row 1 -column 2  \
        -sticky ew
    grid $base.lblActionType -in $root    -row 2 -column 1  \
        -sticky nw
    grid $base.tom_ActionTypeMenu -in $root    -row 2 -column 2  \
        -sticky nesw
    grid $base.label#3 -in $base.frmActionParamHolder    -row 1 -column 1 
    grid $base.btnActionOk -in $base.frmActionButtons    -row 1 -column 1 
    grid $base.btnActionCancel -in $base.frmActionButtons    -row 1 -column 2 

    # Resize behavior management

    grid rowconfigure $base.frmActionButtons 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmActionButtons 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmActionButtons 2 -weight 0 -minsize 30 -pad 0

    grid rowconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid rowconfigure $root 2 -weight 0 -minsize 30 -pad 0
    grid rowconfigure $root 3 -weight 1 -minsize 30 -pad 0
    grid rowconfigure $root 4 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $root 2 -weight 1 -minsize 30 -pad 0

    grid rowconfigure $base.frmActionParamHolder 1 -weight 0 -minsize 30 -pad 0
    grid rowconfigure $base.frmActionParamHolder 2 -weight 1 -minsize 30 -pad 0
    grid columnconfigure $base.frmActionParamHolder 1 -weight 1 -minsize 30 -pad 0

    update
    grab $base
    wm transient $base

    if { $Script::curActionType != "Select Type" } {
        $actionTypeMenu invoke [lsearch $Script::actionTypesList $Script::curActionType]
    }
# additional interface code
    wm title $base "Script Action Editor"
# end additional interface code
}

proc ScriptActionValidateName {newval} {
    if { [ string length $newval ] != 0 && \
     $Script::curActionType != "Select Type"} {
        .frm_ScriptActionEditor.btnActionOk configure -state normal
    } else {
        .frm_ScriptActionEditor.btnActionOk configure -state disabled
    }
    return 1
}

proc KillAllChildren {root} {
    foreach w [winfo children $root] {
    KillAllChildren $w
        destroy $w
   }
}

proc ScriptActionBlank {} {
    set Script::curAction(STOP_FUNC) ""
    set Script::curAction(RUN_FUNC) ""
    set Script::curAction(TYPE) "Select Type"
    array unset Script::curAction PARAMS
    array unset Script::curActionParams
}

# ***************************** Message Action procs **************************
proc EditMessageAction {root} {
    if { $Script::curAction(TYPE) != $Script::actionNames(ACTION_NAME_PRINT_MESSAGE) } {
        ScriptActionBlank
        ScriptActionMessageInitialize
    }

    if { $Script::curAction(NAME) != "" } {
        .frm_ScriptActionEditor.btnActionOk configure -state normal
    }
    set Script::actionValidate "EditMessageActionValidate"

    KillAllChildren $root

    if {$root == "."} {
        set base ""
    } else {
        set base $root
    }
    
    label $base.lblActionMessage \
        -text Message:

    entry $base.ent_ActionMessageMessage \
        -textvariable Script::curActionParams(MESSAGE)


    # Add contents to menus

    # Geometry management

    grid $base.lblActionMessage -in $root    -row 1 -column 1  \
        -sticky w
    grid $base.ent_ActionMessageMessage -in $root    -row 1 -column 2  \
        -sticky ew

    # Resize behavior management

    grid rowconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $root 2 -weight 1 -minsize 30 -pad 0
# additional interface code
# end additional interface code

}

proc EditMessageActionValidate {} {
    if { ! [string length $Script::curActionParams(MESSAGE)] } {
        show_message "Need to supply a message" .frm_ScriptActionEditor
    return 0
    } else {
    return 1
    }
}

proc ScriptActionMessageInitialize {} {
    set Script::curAction(STOP_FUNC) "ScriptActionMessageStop"
    set Script::curAction(RUN_FUNC) "ScriptActionMessageRun"
    set Script::curAction(TYPE) $Script::actionNames(ACTION_NAME_PRINT_MESSAGE)
    # Message Action specific parameters
    set Script::curActionParams(MESSAGE) ""
    set Script::curAction(PARAMS) [array get Script::curActionParams]
}

proc ScriptActionMessageStop {} {
    # This action is fast, so we don't have to do anything
    set Script::actionResult aborted
}

proc ScriptActionMessageRun {} {
    global lastlogchar config
    set scroll_at_bottom \
            [expr { [lindex [.txtfrm.txt yview] 1] >= 1.0 }]
    .txtfrm.txt configure -state normal
    .txtfrm.txt insert end "\n"
    .txtfrm.txt insert end $Script::curActionParams(MESSAGE)
    .txtfrm.txt insert end "\n"
    .txtfrm.txt delete 1.0 end-${config(MAXLINES)}l 
    .txtfrm.txt configure -state disabled

    #Move the buffer view to the end if necessary
    if { $scroll_at_bottom || $config(FOLLOW) } {
         .txtfrm.txt see end
    }

    if { $Log::logging } {
        puts -nonewline $Log::logfile "\n"
        if { $config(LOGDATE) } {
            puts -nonewline $Log::logfile [clock format [clock seconds] -format $config(LOGDATEFORMAT) ]
        }
        puts -nonewline $Log::logfile $Script::curActionParams(MESSAGE)
        puts -nonewline $Log::logfile "\n"
        set lastlogchar $"\n"
        flush $Log::logfile
    }
}

# ***************************** Sleep Action procs **************************
proc EditSleepAction {root} {
    if { $Script::curAction(TYPE) != $Script::actionNames(ACTION_NAME_SLEEP) } {
        ScriptActionBlank
        ScriptActionSleepInitialize
    }

    if { $Script::curAction(NAME) != "" } {
        .frm_ScriptActionEditor.btnActionOk configure -state normal
    }
    set Script::actionValidate "EditSleepActionValidate"

    KillAllChildren $root

    if {$root == "."} {
        set base ""
    } else {
        set base $root
    }
    
    label $base.lblActionSleep \
        -text "Sleep time (ms):"

    entry $base.ent_ActionSleepTime \
        -textvariable Script::curActionParams(TIME) \
    -validate all \
    -width 6 \
    -vcmd "ActionSleepValidateTime %P"

    # Add contents to menus

    # Geometry management

    grid $base.lblActionSleep -in $root    -row 1 -column 1  \
        -sticky w
    grid $base.ent_ActionSleepTime -in $root    -row 1 -column 2  \
        -sticky ew

    # Resize behavior management

    grid rowconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $root 2 -weight 1 -minsize 30 -pad 0
    grid columnconfigure $root 3 -weight 0 -minsize 30 -pad 0
# additional interface code
# end additional interface code

}

proc ActionSleepValidateTime { val } {
    return [string is integer $val]
}

proc EditSleepActionValidate {} {
    if { ! [string length $Script::curActionParams(TIME)] } {
        show_message "Need to supply a sleep time!" .frm_ScriptActionEditor
    return 0
    } else {
    return 1
    }
}

proc ScriptActionSleepInitialize {} {
    set Script::curAction(STOP_FUNC) "ScriptActionSleepStop"
    set Script::curAction(RUN_FUNC) "ScriptActionSleepRun"
    set Script::curAction(TYPE) $Script::actionNames(ACTION_NAME_SLEEP)
    # Sleep Action specific parameters
    set Script::curActionParams(TIME) ""
    set Script::curAction(PARAMS) [array get Script::curActionParams]
}

proc ScriptActionSleepStop {} {
    set Script::actionResult aborted
}

proc ScriptActionSleepRun {} {
    append Script::status " (sleeping $Script::curActionParams(TIME) ms)"
    set after_id [after $Script::curActionParams(TIME) set Script::actionResult done]
    vwait Script::actionResult
    after cancel $after_id
}

# ***************************** Wait For Action procs **************************
proc EditWaitForAction {root} {
    if { $Script::curAction(TYPE) != $Script::actionNames(ACTION_NAME_WAIT_FOR) } {
        ScriptActionBlank
        ScriptActionWaitForInitialize
    }

    if { $Script::curAction(NAME) != "" } {
        .frm_ScriptActionEditor.btnActionOk configure -state normal
    }
    set Script::actionValidate "EditWaitForActionValidate"

    KillAllChildren $root


    if {$root == "."} {
        set base ""
    } else {
        set base $root
    }
    
    frame $base.frmActionWaitForTimeoutType

    frame $base.frmActionWaitForTimeoutValToTake

    frame $base.frmActionWaitForTimeoutVal

    label $base.lblActionWaitForType \
        -text Type:

    frame $base.frmActionWaitForPrompt
    radiobutton $base.rbActionWaitForPrompt \
        -borderwidth 0 \
        -text {Wait for Prompt} \
        -value prompt \
	-command {.frm_ScriptActionEditor.frmActionParameters.entActionWaitForText configure -state disabled} \
        -variable Script::curActionParams(WAIT_FOR_TYPE)

    frame $base.frmActionWaitForText
    radiobutton $base.rbActionWaitForText \
        -borderwidth 0 \
        -text {Wait for following text: } \
        -value text \
	-command {.frm_ScriptActionEditor.frmActionParameters.entActionWaitForText configure -state normal} \
        -variable Script::curActionParams(WAIT_FOR_TYPE)

    entry $base.entActionWaitForText \
        -borderwidth 2 \
        -cursor {} \
	-relief sunken \
        -textvariable Script::curActionParams(TEXT) \
        -width 30

    frame $base.frmActionWaitForIdle
    radiobutton $base.rbActionWaitForIdle \
        -borderwidth 0 \
        -text "Wait for" \
        -value idle \
	-command {.frm_ScriptActionEditor.frmActionParameters.entActionWaitForIdle configure -state normal} \
        -variable Script::curActionParams(WAIT_FOR_TYPE)

    entry $base.entActionWaitForIdle \
        -cursor {} \
	-borderwidth 2 \
        -textvariable Script::curActionParams(IDLE_TIME) \
        -validate all \
	-relief sunken \
        -validatecommand "ActionWaitForValidateIdleTime %P"\
        -width 8

    label $base.lblActionWaitForIdleMS \
        -text "milliseconds of inactivity"

    label $base.lblActionWaitForTime \
        -text Timeout:

    radiobutton $base.cbActionWaitForWaitForever \
        -borderwidth 0 \
        -text {Wait forever} \
        -value never \
	-command {
            .frm_ScriptActionEditor.frmActionParameters.entActionWaitForTime configure -state disabled
            } \
        -variable Script::curActionParams(TIMEOUT_TYPE)

    radiobutton $base.cbActionWaitForWaitForTime \
        -text Wait \
        -value timeout \
	-command {
            .frm_ScriptActionEditor.frmActionParameters.entActionWaitForTime configure -state normal
            } \
        -variable Script::curActionParams(TIMEOUT_TYPE)

    entry $base.entActionWaitForTime \
        -cursor {} \
	-borderwidth 2 \
        -textvariable Script::curActionParams(TIME) \
        -validate all \
	-relief sunken \
        -validatecommand "ActionWaitForValidateTime %P"\
        -width 8

    label $base.lblActionWaitForTimeoutMS \
        -text milliseconds

    label $base.lblctionWaitForTimeoutAction \
        -text {Timeout Action:}

    checkbutton $base.cbActionWaitForStopScript \
        -borderwidth 0 \
        -text {Stop Running Script} \
        -variable Script::curActionParams(TIMEOUT_STOP_SCRIPT)

    checkbutton $base.cbActionWaitForUserMessage \
        -borderwidth 0 \
        -text {User message: } \
	-command { 
	    if { $Script::curActionParams(TIMEOUT_USER_MESSAGE) } {
                 .frm_ScriptActionEditor.frmActionParameters.entActionWaitForUserMessage configure -state normal
            } else {
                 .frm_ScriptActionEditor.frmActionParameters.entActionWaitForUserMessage configure -state disabled
            } } \
	-onvalue 1 \
	-offvalue 0 \
        -variable Script::curActionParams(TIMEOUT_USER_MESSAGE)

    entry $base.entActionWaitForUserMessage \
        -borderwidth 2 \
	-width 40 \
	-relief sunken \
        -textvariable Script::curActionParams(TIMEOUT_USER_MESSAGE_CONTENT)

    checkbutton $base.cbActionWaitForPrintMessage \
        -borderwidth 0 \
        -text {Print message: } \
	-command { 
	    if { $Script::curActionParams(TIMEOUT_PRINT_MESSAGE) } {
                 .frm_ScriptActionEditor.frmActionParameters.entActionWaitForPrintMessage configure -state normal
            } else {
                 .frm_ScriptActionEditor.frmActionParameters.entActionWaitForPrintMessage configure -state disabled
            } } \
	-onvalue 1 \
	-offvalue 0 \
        -variable Script::curActionParams(TIMEOUT_PRINT_MESSAGE)

    entry $base.entActionWaitForPrintMessage \
        -borderwidth 2 \
	-width 40 \
	-relief sunken \
        -textvariable Script::curActionParams(TIMEOUT_PRINT_MESSAGE_CONTENT)

    if { ! $Script::curActionParams(TIMEOUT_PRINT_MESSAGE) } {
        .frm_ScriptActionEditor.frmActionParameters.entActionWaitForPrintMessage configure -state disabled
    }

    # Add contents to menus

    # Geometry management

    grid $base.frmActionWaitForTimeoutType -in $root    -row 1 -column 2  \
        -sticky ew
    grid $base.frmActionWaitForTimeoutValToTake -in $root    -row 5 -column 2  \
        -sticky ew
    grid $base.frmActionWaitForTimeoutVal -in $root    -row 3 -column 2  \
        -sticky w
    grid $base.lblActionWaitForType -in $root    -row 1 -column 1  \
        -sticky ne

    grid $base.frmActionWaitForPrompt -in $base.frmActionWaitForTimeoutType    -row 1 -column 1  \
        -sticky ew
    grid $base.rbActionWaitForPrompt -in $base.frmActionWaitForPrompt    -row 1 -column 1  \
        -sticky w

    grid $base.frmActionWaitForText -in $base.frmActionWaitForTimeoutType    -row 2 -column 1 \
        -sticky ew
    grid $base.rbActionWaitForText -in $base.frmActionWaitForText    -row 1 -column 1 
    grid $base.entActionWaitForText -in $base.frmActionWaitForText    -row 1 -column 2  \
        -sticky ew

    grid $base.frmActionWaitForIdle -in $base.frmActionWaitForTimeoutType    -row 3 -column 1 \
        -sticky ew
    grid $base.rbActionWaitForIdle -in $base.frmActionWaitForIdle    -row 1 -column 1 \
        -sticky w
    grid $base.entActionWaitForIdle -in $base.frmActionWaitForIdle    -row 1 -column 2  \
        -sticky w
    grid $base.lblActionWaitForIdleMS -in $base.frmActionWaitForIdle    -row 1 -column 3 \
        -sticky w

    grid $base.lblActionWaitForTime -in $root    -row 3 -column 1  \
        -sticky ne
    grid $base.cbActionWaitForWaitForever -in $base.frmActionWaitForTimeoutVal    -row 1 -column 1  \
        -columnspan 3 \
        -sticky w
    grid $base.cbActionWaitForWaitForTime -in $base.frmActionWaitForTimeoutVal    -row 2 -column 1 
    grid $base.entActionWaitForTime -in $base.frmActionWaitForTimeoutVal    -row 2 -column 2  \
        -sticky w
    grid $base.lblActionWaitForTimeoutMS -in $base.frmActionWaitForTimeoutVal    -row 2 -column 3 
    grid $base.lblctionWaitForTimeoutAction -in $root    -row 5 -column 1  \
        -sticky ne
    grid $base.cbActionWaitForStopScript -in $base.frmActionWaitForTimeoutValToTake    -row 1 -column 1  \
        -columnspan 2 \
        -sticky w
    grid $base.cbActionWaitForUserMessage -in $base.frmActionWaitForTimeoutValToTake    -row 2 -column 1  \
        -sticky w
    grid $base.entActionWaitForUserMessage -in $base.frmActionWaitForTimeoutValToTake    -row 2 -column 2  \
        -sticky ew
    grid $base.cbActionWaitForPrintMessage -in $base.frmActionWaitForTimeoutValToTake    -row 3 -column 1 -sticky w
    grid $base.entActionWaitForPrintMessage -in $base.frmActionWaitForTimeoutValToTake    -row 3 -column 2  \
        -sticky ew

    # Resize behavior management

    grid rowconfigure $base.frmActionWaitForTimeoutValToTake 1 -weight 0 -minsize 2 -pad 0
    grid rowconfigure $base.frmActionWaitForTimeoutValToTake 2 -weight 0 -minsize 2 -pad 0
    grid rowconfigure $base.frmActionWaitForTimeoutValToTake 3 -weight 0 -minsize 6 -pad 0
    grid columnconfigure $base.frmActionWaitForTimeoutValToTake 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmActionWaitForTimeoutValToTake 2 -weight 1 -minsize 30 -pad 0

    grid rowconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid rowconfigure $root 2 -weight 0 -minsize 17 -pad 0
    grid rowconfigure $root 3 -weight 0 -minsize 2 -pad 0
    grid rowconfigure $root 4 -weight 0 -minsize 14 -pad 0
    grid rowconfigure $root 5 -weight 0 -minsize 6 -pad 0
    grid columnconfigure $root 1 -weight 0 -minsize 17 -pad 0
    grid columnconfigure $root 2 -weight 1 -minsize 30 -pad 0

    grid rowconfigure $base.frmActionWaitForTimeoutVal 1 -weight 0 -minsize 8 -pad 0
    grid rowconfigure $base.frmActionWaitForTimeoutVal 2 -weight 0 -minsize 3 -pad 0
    grid columnconfigure $base.frmActionWaitForTimeoutVal 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmActionWaitForTimeoutVal 2 -weight 0 -minsize 7 -pad 0
    grid columnconfigure $base.frmActionWaitForTimeoutVal 3 -weight 0 -minsize 30 -pad 0

    grid rowconfigure $base.frmActionWaitForTimeoutType 1 -weight 0 -minsize 11 -pad 0
    grid rowconfigure $base.frmActionWaitForTimeoutType 2 -weight 0 -minsize 2 -pad 0
    grid rowconfigure $base.frmActionWaitForTimeoutType 3 -weight 0 -minsize 2 -pad 0
    grid columnconfigure $base.frmActionWaitForTimeoutType 1 -weight 1 -minsize 30 -pad 0

    grid rowconfigure $base.frmActionWaitForPrompt 1 -weight 0 -minsize 11 -pad 0
    grid columnconfigure $base.frmActionWaitForPrompt 1 -weight 1 -minsize 30 -pad 0
    grid rowconfigure $base.frmActionWaitForText 1 -weight 0 -minsize 11 -pad 0
    grid columnconfigure $base.frmActionWaitForText 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmActionWaitForText 2 -weight 1 -minsize 30 -pad 0
    grid rowconfigure $base.frmActionWaitForIdle 1 -weight 0 -minsize 11 -pad 0
    grid columnconfigure $base.frmActionWaitForIdle 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmActionWaitForIdle 2 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $base.frmActionWaitForIdle 3 -weight 1 -minsize 30 -pad 0
    update
    wm minsize .frm_ScriptActionEditor [winfo width .frm_ScriptActionEditor] [winfo height .frm_ScriptActionEditor]

}

proc ActionWaitForValidateIdleTime { val } {
    if { [string is integer $val] && $val > 0 } { return 1 } else { return 0 }
}

proc ActionWaitForValidateTime { val } {
    return [string is integer $val]
}

proc EditWaitForActionValidate {} {
    set errorMessage ""
    if { $Script::curActionParams(WAIT_FOR_TYPE) == "text" } {
        if { ! [string length $Script::curActionParams(TEXT)] } {
	    append errorMessage "For the selected type, you must supply the text to wait for.\n"
	}
    }

    if { $Script::curActionParams(TIMEOUT_TYPE) == "timeout" } {
        if { ! [string length $Script::curActionParams(TIME)] } {
	    append errorMessage "For the selected timeout, you must supply the time to wait.\n"
	}
    }

    if { $Script::curActionParams(WAIT_FOR_TYPE) == "idle" } {
        if { ! [string length $Script::curActionParams(IDLE_TIME)] } {
	    append errorMessage "For the selected type, you must supply the inactivity time to wait for.\n"
	}
        if { $Script::curActionParams(TIMEOUT_TYPE) == "timeout" && \
             [string length $Script::curActionParams(TIME)] } {
            if { $Script::curActionParams(TIME) <= $Script::curActionParams(IDLE_TIME) } {
	        append errorMessage "When waiting for inactivity, the timeout must be at least as long as the inactivity time.\n"
            }
        }
    }

    if { $Script::curActionParams(TIMEOUT_USER_MESSAGE) } {
        if { ! [string length $Script::curActionParams(TIMEOUT_USER_MESSAGE_CONTENT)] } {
	    append errorMessage "You selected to present the user a message, so you must supply the message.\n"
	}
    }

    if { $Script::curActionParams(TIMEOUT_PRINT_MESSAGE) } {
        if { ! [string length $Script::curActionParams(TIMEOUT_PRINT_MESSAGE_CONTENT)] } {
	    append errorMessage "You selected to print a message to the buffer, so you must supply the message.\n"
	}
    }
    if { [string length $errorMessage] } {
        show_message $errorMessage .frm_ScriptActionEditor
        return 0
    } else {
        return 1
    }
}

proc ScriptActionWaitForInitialize {} {
    set Script::curAction(STOP_FUNC) "ScriptActionWaitForStop"
    set Script::curAction(RUN_FUNC) "ScriptActionWaitForRun"
    set Script::curAction(TYPE) $Script::actionNames(ACTION_NAME_WAIT_FOR)
    # WaitFor Action specific parameters
    set Script::curActionParams(WAIT_FOR_TYPE) prompt
    set Script::curActionParams(TEXT) ""
    set Script::curActionParams(IDLE_TIME) ""
    set Script::curActionParams(TIMEOUT_TYPE) never
    set Script::curActionParams(TIME) ""
    set Script::curActionParams(TIMEOUT_STOP_SCRIPT) 0
    set Script::curActionParams(TIMEOUT_USER_MESSAGE) 0
    set Script::curActionParams(TIMEOUT_USER_MESSAGE_CONTENT) ""
    set Script::curActionParams(TIMEOUT_PRINT_MESSAGE) 0
    set Script::curActionParams(TIMEOUT_PRINT_MESSAGE_CONTENT) ""
    set Script::curAction(PARAMS) [array get Script::curActionParams]
}

proc ScriptActionWaitForStop {} {
    set Script::actionResult aborted
}

proc ScriptActionWaitForRun {} {
    if { $Script::curActionParams(WAIT_FOR_TYPE) == "prompt" } {
        append Script::status "  (waiting for prompt)"
        set Script::waitText $Script::prompt
        set Script::waitingForText 1
    } elseif { $Script::curActionParams(WAIT_FOR_TYPE) == "text" } {
        append Script::status "  (waiting for \"$Script::curActionParams(TEXT)\")"
        set Script::waitText $Script::curActionParams(TEXT)
        set Script::waitingForText 1
        set Script::waitingForIdle 0
    } else {
        append Script::status "  (waiting for " $Script::curActionParams(IDLE_TIME) " ms of inactivity)\")"
        set Script::waitText "bjasdlfjaljksf"
        set Script::waitingForText 0
        set Script::waitIdleTime $Script::curActionParams(IDLE_TIME)
        set Script::waitingForIdle 1
        set Script::waitIdleId [after $Script::waitIdleTime {set Script::waitingForIdle 0; set Script::actionResult done}]
    }

    if { $Script::curActionParams(TIMEOUT_TYPE) == "timeout" } {
        set wait_id [after $Script::curActionParams(TIME) {set Script::waitingForText 0; set Script::actionResult timeout}]
    }

    vwait Script::actionResult

    if { $Script::curActionParams(TIMEOUT_TYPE) == "timeout" } {
        after cancel $wait_id
    }

    if { $Script::waitingForIdle } {
        after cancel $Script::waitIdleId
        set Script::waitingForIdle 0
    }

    if { $Script::actionResult == "timeout" } {
        if { $Script::curActionParams(TIMEOUT_USER_MESSAGE) } {
            show_message $Script::curActionParams(TIMEOUT_USER_MESSAGE_CONTENT) .f_Scripter
	}
        if { $Script::curActionParams(TIMEOUT_PRINT_MESSAGE) } {
            global lastlogchar config
            .txtfrm.txt configure -state normal
            .txtfrm.txt insert end "\n"
            .txtfrm.txt insert end $Script::curActionParams(TIMEOUT_PRINT_MESSAGE_CONTENT)
            .txtfrm.txt insert end "\n"
            .txtfrm.txt configure -state disabled

            if { $Log::logging } {
                puts -nonewline $Log::logfile "\n"
                if { $config(LOGDATE) } {
                    puts -nonewline $Log::logfile [clock format [clock seconds] -format $config(LOGDATEFORMAT) ]
                }
                puts -nonewline $Log::logfile $Script::curActionParams(TIMEOUT_PRINT_MESSAGE_CONTENT)
                puts -nonewline $Log::logfile "\n"
                set lastlogchar $"\n"
                flush $Log::logfile
            }
        }
        if { $Script::curActionParams(TIMEOUT_STOP_SCRIPT) } {
             set Script::running 0
	}
    }
    set Script::waitBuffer ""
}


# ***************************** SendCommand Action procs **************************
proc EditSendCommandAction {root} {
    if { $Script::curAction(TYPE) != $Script::actionNames(ACTION_NAME_SEND_COMMAND) } {
        ScriptActionBlank
        ScriptActionSendCommandInitialize
    }

    if { $Script::curAction(NAME) != "" } {
        .frm_ScriptActionEditor.btnActionOk configure -state normal
    }
    set Script::actionValidate "EditSendCommandActionValidate"

    KillAllChildren $root

    if {$root == "."} {
        set base ""
    } else {
        set base $root
    }
    
    label $base.lblActionSendCommand \
        -text "Command to send:"

    entry $base.ent_ActionSendCommandCommand \
        -textvariable Script::curActionParams(COMMAND) \
	-width 40

    # Add contents to menus

    # Geometry management

    grid $base.lblActionSendCommand -in $root    -row 1 -column 1  \
        -sticky w
    grid $base.ent_ActionSendCommandCommand -in $root    -row 1 -column 2  \
        -sticky ew

    # Resize behavior management

    grid rowconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $root 2 -weight 1 -minsize 30 -pad 0
# additional interface code
# end additional interface code

}

proc EditSendCommandActionValidate {} {
    return 1
}

proc ScriptActionSendCommandInitialize {} {
    set Script::curAction(STOP_FUNC) "ScriptActionSendCommandStop"
    set Script::curAction(RUN_FUNC) "ScriptActionSendCommandRun"
    set Script::curAction(TYPE) $Script::actionNames(ACTION_NAME_SEND_COMMAND)
    # SendCommand Action specific parameters
    set Script::curActionParams(COMMAND) ""
    set Script::curAction(PARAMS) [array get Script::curActionParams]
}

proc ScriptActionSendCommandStop {} {
    # This action is fast, so we don't have to do anything
    set Script::actionResult aborted
}

proc ScriptActionSendCommandRun {} {
    global SRLFILE
    #Wait for idle between each character sent to the connection in
    #order to prevent lost bytes.  This should not be necessary, but it
    #appears to help.
    for { set ind 0 } { $ind < [string length "$Script::curActionParams(COMMAND)"] && $Script::running} { incr ind } {
        puts -nonewline $SRLFILE [string index "$Script::curActionParams(COMMAND)" $ind]
        set x 0
        after 5 set x 1
        vwait x
    }
    puts -nonewline $SRLFILE \n
    set Script::actionResult done
}

# ***************************** UserInteraction Action procs **************************
proc EditUserInteractionAction {root} {
    if { $Script::curAction(TYPE) != $Script::actionNames(ACTION_NAME_USER_INTERACTION) } {
        ScriptActionBlank
        ScriptActionSendUserInteractionInitialize
    }

    if { $Script::curAction(NAME) != "" } {
        .frm_ScriptActionEditor.btnActionOk configure -state normal
    }

    KillAllChildren $root

    if {$root == "."} {
        set base ""
    } else {
        set base $root
    }

    set Script::actionValidate EditSendUserInteractionActionValidate
    
    label $base.lblActionSendUserInteraction \
        -text "Message to user:"

    text $base.txt_ActionSendUserInteractionMessage \
	-width 40 -height 10 \
	-yscrollcommand "$base.scrlActionSendUserInteractionMessage set"

    scrollbar $base.scrlActionSendUserInteractionMessage \
        -command "$base.txt_ActionSendUserInteractionMessage yview" \

    # Add contents to menus

    # Geometry management

    grid $base.lblActionSendUserInteraction -in $root    -row 1 -column 1  \
        -sticky w
    grid $base.txt_ActionSendUserInteractionMessage -in $root    -row 1 -column 2  \
        -sticky nsew
    grid $base.scrlActionSendUserInteractionMessage -in $root    -row 1 -column 3  \
        -sticky ns

    # Resize behavior management

    grid rowconfigure $root 1 -weight 1 -minsize 30 -pad 0
    grid columnconfigure $root 1 -weight 0 -minsize 30 -pad 0
    grid columnconfigure $root 2 -weight 1 -minsize 30 -pad 0
    grid columnconfigure $root 3 -weight 0 -minsize 30 -pad 0
# additional interface code

    $base.txt_ActionSendUserInteractionMessage insert end $Script::curActionParams(MESSAGE)
# end additional interface code

}

proc EditSendUserInteractionActionValidate {} {
    set Script::curActionParams(MESSAGE) [.frm_ScriptActionEditor.frmActionParameters.txt_ActionSendUserInteractionMessage get 0.0 end]
    return 1
}

proc ScriptActionSendUserInteractionInitialize {} {
    set Script::curAction(STOP_FUNC) "ScriptActionSendUserInteractionStop"
    set Script::curAction(RUN_FUNC) "ScriptActionSendUserInteractionRun"
    set Script::curAction(TYPE) $Script::actionNames(ACTION_NAME_USER_INTERACTION)
    # User Interaction Action specific parameters
    set Script::curActionParams(MESSAGE) ""
    set Script::curAction(PARAMS) [array get Script::curActionParams]
}

proc ScriptActionSendUserInteractionStop {} {
    # This action is fast, so we don't have to do anything
    set Script::actionResult aborted
}

proc ScriptActionSendUserInteractionRun {} {
    show_message $Script::curActionParams(MESSAGE) .f_Scripter
    set Script::actionResult done
}

# ***********************************************************************

# Open the connection
open_connection config

if { $display } {

    array set Hist::autoCompleteList {}
    array set Script::curAction {}
    array set Script::curActionParams {}
    set Hist::curAutoCompleteMatchIndex -1
    set Hist::autoCompleteMatchList [list]
    for {set i 0} {$i < $config(MAXCOMMANDS)} {incr i} {
        set Cmd::entryText($i) ""
    }
    if { $config(AUTOCOMPLETEFILE) != "none" && ! [catch {open $config(AUTOCOMPLETEFILE) r} acFileId] } {
        gets $acFileId line
        if { $line == "R2" } {
            gets $acFileId line
        }
        catch [array set Hist::autoCompleteList $line]
        close $acFileId
    }

    #Try to read in the auto completion list
    menu .menubar -type menubar
     .menubar add cascade -label File -menu .menubar.file -underline 0
     .menubar add cascade -label Tools -menu .menubar.tools -underline 0
     .menubar add cascade -label Find -menu .menubar.find -underline 1
     .menubar add cascade -label Help -menu .menubar.help -underline 0

    #file menu
     menu .menubar.file -tearoff 0
     .menubar.file add command -label Exit -underline 1 -command { exit}
     #end file menu

    #tools menu
     menu .menubar.tools -tearoff 0
     .menubar.tools add command -label "Reset On-the-fly Tags (Ctrl-R)" -underline 0 \
     -command { reset_tags }
     .menubar.tools add command -label "Clear Buffer (Ctrl-E)" -underline 0 \
     -command { cleartxt }
     .menubar.tools add command -label "Save Current Buffer..." -underline 0 \
     -command { dump }
     .menubar.tools add command -label "Start Logging (Ctrl-L)" -underline 0 \
     -command { startlog }
     .menubar.tools add command -label "Toggle Command Entries Visible (Ctrl-H)" -underline 0 \
     -command { toggle_hide_commands }
     .menubar.tools add command -label "Save Commands (Ctrl-S)" -underline 0 \
     -command { savecmds }
     .menubar.tools add command -label "Save Commands As (Ctrl-A)" -underline 14 \
     -command { savecmdsas }
     .menubar.tools add command -label "Options..." \
     -command get_options
     .menubar.tools add command -label "ScriptRunner..." -underline 7 \
     -command Scripter
     #end tools menu

    #find menu
     menu .menubar.find -tearoff 0
     .menubar.find add command -label "Find selection (Ctrl-F)" -underline 0 \
         -command "find_text"

     #Help menu
     menu .menubar.help -tearoff 0
     .menubar.help add command -label "Usage" -underline 0 \
     -command { toplevel .usage 
                usage .usage {} {grab release .usage;destroy .usage}
                grab .usage
                wm transient .usage}
     .menubar.help add command -label "Colors" -underline 0 \
     -command { toplevel .colors; 
                list_colors .colors {grab release .colors;destroy .colors}
                grab .colors
                wm transient .colors}

     . configure -menu .menubar
     #End of menu bar

    #set i 0
    #Create the text buffer
    frame .txtfrm
    if { $config(WRAP) } {
        text .txtfrm.txt -yscrollcommand ".txtfrm.srl_y set" \
                -width 80 -height 40 -state disabled -bg "${config(BACKGROUND)}" -fg "${config(FOREGROUND)}" \
                -insertbackground "${config(FOREGROUND)}" -selectforeground "${config(BACKGROUND)}" \
                -selectbackground "${config(FOREGROUND)}" \
                -font "${config(TEXTFONT)} ${config(TEXTSIZE)}" 
    } else {
        text .txtfrm.txt -yscrollcommand ".txtfrm.srl_y set" -xscrollcommand ".txtfrm.srl_x set"  \
                -width 80 -height 40 -state disabled -bg "${config(BACKGROUND)}" -fg "${config(FOREGROUND)}" \
                -insertbackground "${config(FOREGROUND)}" -selectforeground "${config(BACKGROUND)}" \
                -selectbackground "${config(FOREGROUND)}" -wrap none \
                -font "${config(TEXTFONT)} ${config(TEXTSIZE)}" 
        scrollbar .txtfrm.srl_x -orient h -command ".txtfrm.txt xview"
    }

    scrollbar .txtfrm.srl_y -orient v -command ".txtfrm.txt yview"

    if { $config(FOLLOW) } {
        .txtfrm.srl_y configure -bg "maroon4"
    } else {
        .txtfrm.srl_y configure -bg [.menubar cget -bg]
    }

    #create the manual command entry 
    entry .cmdent -bg "${config(BACKGROUND)}" -fg "${config(FOREGROUND)}" \
            -insertbackground "${config(FOREGROUND)}" -selectforeground "${config(BACKGROUND)}" \
            -selectbackground "${config(FOREGROUND)}" \
            -font "${config(TEXTFONT)} ${config(TEXTSIZE)}" \
            -validate all -validatecommand {autocomplete %W %d %v %P}

    # Make the bottom right box a label which, when clicked, causes the
    # buffer view to go to the bottom
    label .txtbtmlbl -text V -font "arial ${config(TEXTSIZE)} bold"
    bind .txtbtmlbl <ButtonPress> { .txtfrm.txt see end; focus .cmdent }


    #Configure widget layout using grid
    grid .txtfrm.txt -row 0 -column 0 -sticky nsew
    grid .txtfrm.srl_y -row 0 -column 1 -sticky ns
    if { ! $config(WRAP) } {
        grid .txtfrm.srl_x -row 1 -column 0 -sticky ew 
        grid .txtbtmlbl -in .txtfrm -row 1 -column 1
        grid .cmdent -in .txtfrm -row 2 -column 0 -columnspan 2 -sticky ew
    } else {
        grid .txtbtmlbl -in .txtfrm -row 1 -column 1
        grid .cmdent -in .txtfrm -row 1 -column 0 -sticky ew
    }
    grid .txtfrm -row 1 -column 0 -sticky nsew
    grid columnconfigure .txtfrm 0 -weight 1
    grid rowconfigure .txtfrm 0 -weight 1
    grid rowconfigure . 1 -weight 1
    grid columnconfigure . 0 -weight 1

    # OK, our window is now setup and visible
    set numTags [llength $config(TAGINFO)]
    for {set i 0} {$i < $numTags} {incr i} {
        addTag "[lindex $config(TAGINFO) $i]" $i
    }

    #Bind return key in the manual command entry
    bind .cmdent <Return> send_cmd_entry_cmd
    bind .cmdent <Tab> { next_autocomplete; break }
    bind .cmdent <Shift-Tab> { prev_autocomplete; break }
    bindtags .cmdent { .cmdent Entry . all }
    

    #Bind up key in the manual command entry
    bind .cmdent <Up> histup
    #Bind down key in the manual command entry
    bind .cmdent <Down> histdown

    #Bind Ctrl-b to toggling "scroll on activity"
    bind . <Control-b> "set config(SCROLL) 1; new_scroll"    
    #Bind Ctrl-e to clear the text buffer
    bind . <Control-e> "cleartxt"    
    #Bind Ctrl-s to save the current command entries to the command file
    bind . <Control-s> "savecmds"    
    #Bind Ctrl-s to toggle logging output to file (logging on or logging off)
    bind . <Control-l>  {.menubar.tools invoke 3}
    #Bind Ctrl-a to toggle command autocompletion
    bind . <Control-a> "set config(AUTOCOMPLETE) 1"    
    #Bind Ctrl-f to text search
    bind . <Control-f> ".menubar.find invoke 0"    
    #Bind Ctrl-h to hide preset command entries
    bind . <Control-h> "toggle_hide_commands"    
    #Bind Ctrl-t to tag all text matching selected text
    bind . <Control-t> "tag_from_select"    
    #Bind Ctrl-k to clear tags
    bind . <Control-k> ".txtfrm.txt tag delete \"tagall\""    
    #Bind Ctrl-r to reset on-the-fly tags
    bind . <Control-r> "reset_tags"    

    #Bind default keypress event
    bind .txtfrm.txt <KeyPress> "check_focus %A"
    bind .menubar <ButtonPress> "focus .cmdent"

    #put the focus on the manual command entry
    focus .cmdent

    # Make sure the connection is closed when we close
    bind .txtfrm <Destroy> "close $SRLFILE"

    selection clear .txtfrm.txt

    set lastlogchar \n

    #Read saved commands in and create the preset command entries
    readcmds
    #Set the window title
    #wm title . "$config(SCRIPTNAME) - $config(DEVICE)"

    focus .cmdent
}
